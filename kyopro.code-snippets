{
	/*
	数列　OEIS
	数式　wolframAlpha

	*/

	/*TO DO
	naive combibnation nCr abc057 D
	Tiii
	UF snipet
	ダイコネ
	lowlink
	link cut tree 
	euler tour tree
	editale rolling hash power[r]. r==0
	undo UF
	312b eigen verification
	completebinary tree mint
	一般マッチング
	集合判定
	periodic graph
	黄金比分割探索
	最大流．敷き詰め系
	rope
	chmin, sum セグ木->beats
	45°回転，論理演算，Grundy数,Luca数，フィボナッチ等，有名数の特徴，一般項等メモ
	トポロジカルソート．閉路ない場合の有向グラフの最大距離
	木の重心，重心分解
	CHT
	bin trie
	ゼータ変換？多次元いもす https://yukicoder.me/submissions/830758
	rhの説明
	TSP
	ポラードロー，ミラーカビン
	グラフ色数
	ダイクストラreset関数
	2次元区間和
	coutオプション
	wavelet matrix
	*/


	//テンプレート standard
	//テンプレート minimum
	//インクルードbits

	//atcoder::all
	//atcoder::convolution
	//atcoder::dsu
	//atcoder::lazysegtree
	//atcoder::math
	//atcoder::maxflow
	//atcoder::mincutflow
	//atcoder::modint
	//atcoder::scc
	//atcoder::segtree
	//atcoder::string
	//atcoder::twosat


	//bfs_grid
	//bfs_01
	//boost/geometry/convex hull
	//boost/geometry/intersects
	//boost/multiprecision/float
	//boost/multiprecision/int
	//boost/string
	//builtin
	//dfs_grid
	//DP/LCP
	//DP/LCS
	//DP/LIS
	//dsu
	//dxdy
	//Eigen/Polynomials
	//Graph/graph_template
	//Graph/mst/kruskal
	//Graph/mst/prim
	//Graph/others/cycle_detection
	//Graph/others/lowlink
	//Graph/shortest_path/bellman_ford
	//Graph/shortest_path/dijkstra
	//Graph/shortest_path/warshall_floyed
	//Graph/tree/complete_binary_tree
	//Graph/tree/euler_tour/directed_tree_dist_query
	//Graph/tree/euler_tour/euler_tour
	//Graph/tree/euler_tour/tree_dist_query
	//Graph/tree/hld/hld.hpp
	//Graph/tree/LCA_doubling
	//Graph/tree/LCA_RMQ
	//Graph/tree/rerooting_dp
	//Graph/tree/rooted_tree
	//Graph/tree/tree_diameter
	//lambda
	//lower_bound reverse
	//Math/kth_element
	//Math/matrix/matrix
	//Math/sum_of_K_products
	//mex
	//mex_ebi
	//modint
	//mod逆元
	//n進数表示
	//Others/Mo's algorithm
	//Others/MyHash
	//pair extention
	//PBDS/HashMap
	//PBDS/tree
	//power
	//rand
	//rand(正規分布)
	//shiritori
	//Sort/bubble_sort
	//Sort/merge_sort
	//sqrtll
	//string io split file
	//string replace
	//String/dynamic_rolling_hash.hpp
	//String/editable_rolling_hash.hpp
	//String/rolling_hash.hpp
	//String/treaprolling_hash.hpp
	//Structure/others/cummulative_sum_2d
	//Structure/others/sparse_table
	//Structure/others/range_kth_query
	//Structure/pbds/hash_map
	//Structure/pbds/multiset
	//Structure/pbds/set
	//Structure/pbds/tree
	//Structure/queue/middle_queue
	//Structure/set/top_k_sum_multiset
	//Structure/tree/implicit_treap
	//Structure/tree/ordered_map
	//Structure/tree/ordered_multiset
	//Structure/tree/ordered_set
	//Structure/tree/priority_sum
	//Structure/union_find/union_find
	//Structure/union_find/unordered_map_union_find
	//Structure/union_find/weighted_union_find
	//Structure/union_find/weight_sum_union_find
	//Structure/others/SWAG
	//timer
	//Tips/logic
	//Tips/45deg
	//python%

	//階乗
	//行列計算
	//組み合わせ
	//組み合わせ　大
	//グラフ回転90*n
	//桁数keta
	//座標圧縮
	//しりとり
	//セグ木
	//素数
	//多項式
	//転倒数
	//累積和,累積XOR・等差数列和
	//二分探索
	//熨斗基底
	//バブルソート
	//2次元ベクトル
	//約数列挙
	//ユークリッドの互除法
	//ランレングス圧縮

	"-": {
		"scope": "cpp",
		"prefix": "----",
		"body": [
			"",
		],
		"description": "",
	},

	"テンプレートstandard": {
		"scope": "cpp",
		"prefix": "tennpure-to",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"//const int MOD = 998'244'353;",
			"const int MOD = 1000'000'007;",
			"",
			"const int INF = (1<<30)-1;",
			"const long long LINF = (1LL<<62)-1;",
			"",
			"#define rep(i, n) for (int i = 0; i < (int)(n); i++)",
			"#define repi(i, a, n) for (int i = a; i < (int)(n); i++)",
			"#define repll(i, n) for (ll i = 0; i < (ll)(n); i++)",
			"#define repill(i, a, n) for (ll i = a; i < (ll)(n); i++)",
			"#define pb(a) push_back(a)",
			"#define PS(a) cout<<(a)<<\" \";",
			"#define PL(a) cout<<(a)<<endl;",
			"#define ES(a) cerr<<(a)<<\" \";",
			"#define EL(a) cerr<<(a)<<endl;",
			"#define END(a) {PL(a) return;}",
			"#define FI first",
			"#define SE second",
			"#define ALL(a)  (a).begin(),(a).end()",
			"#define RALL(a)  (a).rbegin(),(a).rend()",
			"#define SORT(a) sort(a.begin(), a.end());",
			"#define REVERSE(a) reverse(a.begin(), a.end());",
			"#define ERASE(a) a.erase(unique(a.begin(), a.end()), a.end());",
			"using ll = long long;",
			"using P = pair<int, int>;",
			"template <class T> using V = vector<T>;",
			"template< typename T >ostream &operator<<(ostream &os, const vector< T > &v) {for(int i = 0; i < (int) v.size(); i++) {os << v[i] << (i + 1 != (int) v.size() ? \" \" : \"\");}return os;}",
			"template< typename T >istream &operator>>(istream &is, vector< T > &v) {for(T &in : v) is >> in;return is;}",
			"template <class T, class U> void chmin(T& t, const U& u) {if (t > u) t = u;}",
			"template <class T, class U> void chmax(T& t, const U& u) {if (t < u) t = u;}",
			"",
			"void solve() {",
			"",
			"   return;",
			"}",
			"",
			"int main() {",
			"   std::cin.tie(nullptr);",
			"   std::ios_base::sync_with_stdio(false);",
			"   std::cout << std::fixed << std::setprecision(15);",
			"   int TT = 1; //cin>>TT;",
			"   for(int tt = 0; tt<TT; tt++) solve();",
			"   return 0;",
			"}",
		],
		"description": "テンプレート standard",
	},

	"テンプレートminimum": {
		"scope": "cpp",
		"prefix": "tennpure-to",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"//const int MOD = 998'244'353;",
			"const int MOD = 1000'000'007;",
			"",
			"const int INF = (1<<30)-1;",
			"const long long LINF = (1LL<<62)-1;",
			"",
			"#define rep(i, n) for (int i = 0; i < (int)(n); i++)",
			"#define repi(i, a, n) for (int i = a; i < (int)(n); i++)",
			"using ll = long long;",
			"template <class T> using V = vector<T>;",
			"template< typename T >ostream &operator<<(ostream &os, const vector< T > &v) {for(int i = 0; i < (int) v.size(); i++) {os << v[i] << (i + 1 != (int) v.size() ? \" \" : \"\");}return os;}",
			"template< typename T >istream &operator>>(istream &is, vector< T > &v) {for(T &in : v) is >> in;return is;}",
			"",
			"void solve() {",
			"",
			"   return;",
			"}",
			"",
			"int main() {",
			"   std::cin.tie(nullptr);",
			"   std::ios_base::sync_with_stdio(false);",
			"   std::cout << std::fixed << std::setprecision(15);",
			"   int TT = 1; //cin>>TT;",
			"   for(int tt = 0; tt<TT; tt++) solve();",
			"   return 0;",
			"}",
		],
		"description": "テンプレート minimum",
	},

	"include": {
		"scope": "cpp",
		"prefix": "include",
		"body": [
			"#include<iostream>",
			"#include<vector>",
			"#include<algorithm>",
			"#include<numeric>",
			"#include<map>",
			"#include<set>",
			"#include<queue>",
			"#include<stack>",
			"#include<cstdlib>",
			"#include<random>",
			"#include<iomanip>",
			"#include<sstream>",
			"#include<limits>",
			"#include<bitset>",
			"#include<functional>",
			"#include<type_traits>",
			"#include<array>",
			"#include<utility>",
			"#include<ctime>",
			"#include<fstream>",
			"using namespace std;"
		],
		"description": "include <bits/stdc++>",
	},

	"atcoder::all": {
		"scope": "cpp",
		"prefix": "atcoder::all",
		"body": [
			"#if __has_include(<atcoder/all>)",
			"#include <atcoder/all>",
			"using namespace atcoder;",
			"#endif",
		],
		"description": "atcoder::all",
	},

	"atcoder::convolution": {
		"scope": "cpp",
		"prefix": "atcoder::convolution",
		"body": [
			"#if __has_include(<atcoder/convolution>)",
			"#include <atcoder/convolution>",
			"using namespace atcoder;",
			"/*",
			"V<int> A(n), B(m);",
			"auto C = atcoder::convolution<MOD>(A, B);",
			"*/",
			"#endif"
		],
		"description": "atcoder::convolution",
	},

	"atcoder::dsu": {
		"scope": "cpp",
		"prefix": "dsu",
		"body": [
			"#if __has_include(<atcoder/dsu>)",
			"#include <atcoder/dsu>",
			"using namespace atcoder;",
			"//dsu DSU(n);",
			"//DSU.merge(a,b);",
			"//if(DSU.same(a,b)){}",
			"#endif",
		],
		"description": "atcoder::dsu",
	},

	"atcoder::lazysegtree": {
		"scope": "cpp",
		"prefix": "lazysegki",
		"body": [
			"#if __has_include(<atcoder/lazysegtree>)",
			"#include <atcoder/lazysegtree>",
			"using namespace atcoder;",
			"#endif",
			"",
			"namespace Lazy{",
			"   template<typename T>",
			"   struct S{",
			"      T x;",
			"      ll size=1;",
			"   };",
			"",
			"   template<typename T>",
			"   struct F{",
			"      T a,b;",
			"   };",
			"",
			"   template<typename T> S<T> opSum(S<T> l, S<T> r){return S<T>{l.x+r.x, l.size+r.size};}",
			"   template<typename T> S<T> opMax(S<T> l, S<T> r){return (l.x>=r.x?l:r);}",
			"   template<typename T> S<T> opMin(S<T> l, S<T> r){return (l.x<=r.x?l:r);}",
			"",
			"   template<typename T> S<T> e0(){return S<T>{0, 1};}",
			"   template<typename T> S<T> eLINF(){return S<T>{LINF, 1};}",
			"   template<typename T> S<T> e_LINF(){return S<T>{-LINF, 1};}",
			"",
			"   template<typename T>",
			"   S<T> FS(F<T> f, S<T> s){",
			"      return S<T>{f.a*s.x+f.b*s.size, s.size};//ax+b",
			"   }",
			"",
			"   template<typename U=ll>",
			"   F<U> FF(F<U> l, F<U> r){",
			"      return F<U>{l.a*r.a, l.a*r.b+l.b};",
			"   }",
			"",
			"   template<typename U=ll>",
			"   F<U> f0(){",
			"      return F<U>{1,0};",
			"   }",
			"   template<typename T=ll> using LazyRSQ = lazy_segtree<S<T>, opSum<T>, e0<T>,     F<T>, FS<T>, FF<T>, f0<T>>;",
			"   template<typename T=ll> using LazyRMQ = lazy_segtree<S<T>, opMax<T>, e_LINF<T>, F<T>, FS<T>, FF<T>, f0<T>>;",
			"   template<typename T=ll> using LazyRmQ = lazy_segtree<S<T>, opMin<T>, eLINF<T>,  F<T>, FS<T>, FF<T>, f0<T>>;",
			"   /*",
			"   ll N,Q; cin>>N>>Q;",
			"   V<ll> A(N); cin>>A;",
			"   Lazy::LazyRSQ<mint> tree(N);",
			"   rep(i,N) tree.set(i, {A[i],1});// {x, size}",
			"",
			"   tree.apply(l,r,LS::F<mint>{a,b});//ax+b",
			"   cout<<tree.prod(l,r).x<<endl;",
			"   */",
			"}"
		],
		"description": "atcoder::segtree"
	},

	"atcoder::math": {
		"scope": "cpp",
		"prefix": "atcoder::math",
		"body": [
			"#include \"atcoder/math\"",
			"/*",
			"V<ll> R = {r1,r2,..};",
			"V<ll> M = {mod1. mod2,..};",
			"auto [ans, found] = atcoder::crt(R, M);",
			"found == lcm(M);",
			"ans + n*lcmは常に満たす",
			"*/"
		],
		"description": "atcoder::math. crt, mod_inv, floor_sum"
	},

	"atcoder::maxflow": {
		"scope": "cpp",
		"prefix": "maxflow",
		"body": [
			"#include <atcoder/maxflow>",
			"using namespace atcoder;",
			"/*",
			"mf_graph<int> mf(N*M+2);",
			"ll s = N*M;",
			"ll t = N*M+1;",
			"mf.add_edge(u,v,1);",
			"ll flow = mf.flow(s,t);",
			"流量の下限が欲しければ，ABC285G,またはLuzhild",
			"*/",
		],
		"description": "atcoder::maxflow.",
	},

	"atcoder::mincutflow": {
		"scope": "cpp",
		"prefix": "mincutflow",
		"body": [
			"#include <atcoder/mincostflow>",
			"/*",
			"    mcf_graph<ll,ll> mcf(N);//cap,cost",
			"    mcf.add_edge(u,v,cap,cost);",
			"    //flow,slopeいづれもF*(n+m)*log(n+m). Fは流量",
			"    auto [cap, cost] = mcf.flow(s,t);",
			"    //流量がxの時，最小コストは/VWみたいになるらしい．",
			"    //slopeの先頭は(x,y)=(0,0),末尾は最大流（or上限）時の最小コスト",
			"    vector<Pll> mcf.slope(s,t);",
			"    auto edges = mcf.edges();",
			"    for(auto& e:edges) cerr<<e.from<<e.to<<e.flow<<endl;",
			"*/"
		],
		"description": "atcoder::mincutflow"
	},

	"atcoder::modint": {
		"scope": "cpp",
		"prefix": "mint",
		"body": [
			"#if __has_include(<atcoder/modint>)",
			"#include <atcoder/modint>",
			"using namespace atcoder;",
			"using mint = atcoder::static_modint<MOD>;",
			"// using mint = atcoder::modint;",
			"// mint::set_mod(MOD);",
			"//制約: a/b -> gcd(b,mod)==1",
			"template<int m> ostream &operator<<(ostream &os, const atcoder::static_modint<m> x) {os<<x.val();return os;}",
			"template<int m> istream &operator>>(istream &is, atcoder::static_modint<m>& x){ll val; is >> val; x = val; return is;}",
			"ostream &operator<<(ostream &os, const atcoder::modint x) {os<<x.val();return os;}",
			"istream &operator>>(istream &is, atcoder::modint& x){ll val; is >> val; x = val; return is;}",
			"#endif",
		],
		"description": "atcoder::modint"
	},

	"atcoder::scc": {
		"scope": "cpp",
		"prefix": "scc",
		"body": [
			"#if __has_include(<atcoder/scc>)",
			"#include <atcoder/scc>",
			"using namespace atcoder;",
			"/*",
			"scc_graph sg(N);",
			"sg.add_edge(u,v);",
			"vector<vector<int>> scc = sg.scc();",
			"//トポロジカルソート済み",
			"//辺のない頂点は長さ1のリストとなる．",
			"*/",
			"#endif"
		],
		"description": "atcoder::scc",
	},

	"atcoder::segtree": {
		"scope": "cpp",
		"prefix": "segki",
		"body": [
			"#if __has_include(<atcoder/segtree>)",
			"#include <atcoder/segtree>",
			"using namespace atcoder;",
			"template<typename T> T opMax(T a, T b){return max(a,b);}",
			"template<typename T> T opMin(T a, T b){return min(a,b);}",
			"template<typename T> T opSum(T a, T b){return a+b;}",
			"template<typename T> T e0(){return T(0);}",
			"template<typename T> T e_LINF(){return -LINF;}",
			"template<typename T> T eLINF(){return LINF;}",
			"",
			"template<typename T=ll> using RMQ = segtree<T, opMax<T>, e_LINF<T>>;//Range Max Query",
			"template<typename T=ll> using RmQ = segtree<T, opMin<T>, eLINF<T>>;// RmQ tree(vec); tree.prod(l,r)",
			"template<typename T=ll> using RSQ = segtree<T, opSum<T>, e0<T>>;",
			"",
			"ll seg_target;",
			"bool f(ll vi){return vi<seg_target;}//seg.max_right<f>(x-1)",
			"bool f2(ll vi){return vi>=seg_target;}//seg.max_right<f>(x-1)",
			"//max_right<f>(l):=>[l:N)でfを満たす右端．",
			"//min_left<f>(r):=>[0:r)でfを満たす左端．",
			"//f(e)=trueでなければならない",
			"//RMQ<ll> tree(N);",
			"//tree.set(i,0);",
			"//tree.get(i);",
			"//tree.prod(l,r);//半開区間",
			"#endif"
		],
		"description": "atcoder::segtree"
	},

	"atcoder::string": {
		"scope": "cpp",
		"prefix": "string",
		"body": [
			"#include <atcoder/string>",
			"using namespace atcoder;",
			"/*",
			"    string S = \"abcdeabcde\";",
			"    //S.substr(i)を辞書順に並び替え.O(N)",
			"    vector<int> sa = suffix_array(S);",
			"    //EL(sa) 5 0 6 1 7 2 8 3 9 4",
			"",
			"    //各suffix arrayについて，S.substr(i)とS.substr(i+1)の最長共通接頭辞",
			"    //O(N)",
			"    vector<int> lcp = lcp_array(S,sa);//N-1",
			"    //EL(lcp) 5 0 4 0 3 0 2 0 1",
			"",
			"    //SとS.substr(i)の最長共通接頭辞.O(N)",
			"    vector<int> z = z_algorithm(S);//",
			"    //EL(z) 10 0 0 0 0 5 0 0 0 0",
			"--------------------------------",
			"   z_algo 回文判定 abczcba z[n+1]==n ->ok",
			"   https://atcoder.jp/contests/wupc2019/submissions/38171302",
			"   複数文字列のLCP↓",
			"   https://blog.hamayanhamayan.com/entry/2017/03/25/005452",
			"*/",
		],
		"description": "atcoder string",
	},

	"atcoder::twosat": {
		"scope": "cpp",
		"prefix": "twosat",
		"body": [
			"#include <atcoder/twosat>",
			"/*",
			"    two_sat ts(N);",
			"    //(uがfalse)かつ(vがfalse)はだめ",
			"    ts.add_clause(u,false, v,false);",
			"    //(uがtrue)かつ(vがfalse)はだめ",
			"    ts.add_clause(u,true, v,false);",
			"    bool res = ts.satisfiable();",
			"    auto answers = ts.answer();",
			"    for(auto ans:answer) cerr<<ans<<endl;",
			"*/"
		],
		"description": "atcoder string",
	},

	"bfs_grid": {
		"scope": "cpp",
		"prefix": "bfs grid",
		"body": [
			"auto GetDistFromStart = [&](ll sx, ll sy)->V<V<ll>> {",
			"   V<V<ll>> dist(H,V<ll>(W, LINF));",
			"   dist[sx][sy] = 0;",
			"   queue<Pll> que;",
			"   que.push({sx, sy});",
			"   while(!que.empty()){",
			"      auto [x, y] = que.front(); que.pop();",
			"      rep(dir,4){",
			"         ll nx = x+dx[dir];",
			"         ll ny = y+dy[dir];",
			"         if(inGrid(nx, ny)&&G[nx][ny]!='#'){",
			"            if(dist[nx][ny]>dist[x][y]+1){",
			"               dist[nx][ny] = dist[x][y]+1;",
			"               que.push({nx, ny});",
			"            }",
			"         }",
			"      }",
			"   }",
			"   return dist;",
			"};"
		],
		"description": "bfs grid",
	},

	"bfs01": {
		"scope": "cpp",
		"prefix": "bfs 01",
		"body": [
			"",
			"//struct state {",
			"//int x, y, dir;",
			"//};",
			"//",
			"//int n; cin>>n;",
			"//int H, W, sx, sy, gx, gy;",
			"//H=n, W=n;",
			"//cin >> sx >> sy >> gx >> gy;",
			"//--sx, --sy, --gx, --gy;",
			"//vector<string> S(n, string(' ',W));",
			"//for(int i=0;i<H;i++) for(int j=0;j<W;j++) cin>>S[i][j];",
			"//",
			"//vector<vector<vector<int>>> dist(n, vector<vector<int>>(n, vector<int>(4, INF)));",
			"//",
			"//deque<state> deq;",
			"//for (int i = 0; i < 4; ++i) {",
			"//dist[sx][sy][i] = 0;",
			"//deq.push_back({ sx, sy, i });",
			"//}",
			"//",
			"//int shortest = INF;",
			"//while (!deq.empty()) {",
			"//state p = deq.front(); deq.pop_front();",
			"//if(shortest<dist[p.x][p.y][p.dir]) break;",
			"//for (int i = 0; i < 4; ++i) {",
			"//int nx = p.x + dx[i];",
			"//int ny = p.y + dy[i];",
			"//int cost = dist[p.x][p.y][p.dir];",
			"//if(p.dir != i) cost++;",
			"//",
			"//if (0 <= nx && nx < H && 0 <= ny && ny < W && S[nx][ny] == '.' && dist[nx][ny][i] > cost) {",
			"//dist[nx][ny][i] = cost;",
			"//if (p.dir != i) deq.push_back({ nx, ny, i });",
			"//else deq.push_front({ nx, ny, i });",
			"//if(nx==gx&&ny==gy) shortest = min(shortest, cost);",
			"//}",
			"//}",
			"//}",
			"//int answer = INF;",
			"//for (int i = 0; i < 4; ++i) {",
			"//answer = min(answer, dist[gx][gy][i]);",
			"//}",
			"//if(answer==INF){",
			"//cout<<-1<<endl;",
			"//return 0;",
			"//}",
			"////曲がった回数をカウントしているので，移動回数は+1",
			"//cout << answer+1 << endl;",
			"//return 0;",
			"//abc170Fの提出のほうが良いかも"
		],
		"description": "01bfs",
	},

	"boost/bimap": {
		"scope": "cpp",
		"prefix": "boost bimap",
		"body": [
			"#include <boost/bimap.hpp>",
			"/*",
			"    typedef bimap<int, multiset_of<string,std::greater<string> > > bm_type;",
			"    bm_type bm;",
			"    bm.insert(bm_type::value_type(1, \"abc\"));",
			"    boost::bimap<int, string> bm;",
			"    bm.insert({1, \"one\"});",
			"    if(bm.left.find(1)!=bm.left.end()){",
			"        PL(bm.left.at(1))",
			"    }",
			"    if(bm.right.find(\"one\")!=bm.right.end()){",
			"        PL(bm.right.at(\"one\"))",
			"    }",
			"    auto it = bm.left.find(1);",
			"    bm.left.replace_key(it, 2);",
			"    bm.left.replace_data(it, \"two\");",
			"    bm.left.replace_key(it, 3);",
			"    bm.left.replace_data(it, \"three\");",
			"    for(auto it2 = bm.left.begin(); it2!=bm.left.end(); it2++){",
			"        PS(it2->first) PL(it2->second)",
			"    }",
			"    for(auto it2 = bm.right.begin(); it2!=bm.right.end(); it2++){",
			"        PS(it2->first) PL(it2->second)",
			"    }",
			"set_of_relation<>",
			"multiset_of_relation<>",
			"unordered_set_of_relation<>",
			"unordered_multiset_of_relation<>",
			"#include <boost/bimap/set_of.hpp>",
			"boost::bimap<boost::bimaps::set_of<int>, boost::bimaps::set_of<string>> bm;",
			"https://www.boost.org/doc/libs/1_81_0/libs/bimap/doc/html/boost_bimap/one_minute_tutorial.html",
			"https://www.boost.org/doc/libs/1_81_0/libs/bimap/doc/html/boost_bimap/the_tutorial/useful_functions.html",
			"https://www.boost.org/doc/libs/1_81_0/libs/bimap/doc/html/boost_bimap/the_tutorial/the_collection_of_relations_type.html",
			"*/"
		],
		"description": "双方向のmap",
	},

	"boost/geometry/intersects": {
		"scope": "cpp",
		"prefix": "boost geometry intersects",
		"body": [
			"#include <boost/geometry/geometries/linestring.hpp>",
			"/*",
			"namespace bg = boost::geometry;",
			"typedef bg::model::d2::point_xy<double> point;",
			"bg::model::linestring<point> linest{{s.fi, s.se}, {t.fi,t.se}};",
			"bool cross = false;",
			"if(!bg::intersects(linest, poly.outer())){",
			"    END(hypot(s.fi-t.fi, s.se-t.se))",
			"}",
			"*/"
		],
		"description": "図形の交点判定．line同士や多角形などで計算可能",
	},

	"boost/geometry/convex hull": {
		"scope": "cpp",
		"prefix": "boost geometry convex hull",
		"body": [
			"#include <boost/geometry.hpp>",
			"#include <boost/geometry/geometries/polygon.hpp>",
			"#include <boost/geometry/geometries/point_xy.hpp>",
			"#include <boost/assign/list_of.hpp>",
			"/*",
			"    https://boostjp.github.io/tips/geometry.html",
			"    pair型としてソートして最小の頂点から開始．必ずxy座標にて時計回り",
			"    複数回呼ぶとclearされずにpush_backされ続けるので，polygon.clear()を呼ぶ",
			"    namespace bg = boost::geometry;",
			"",
			"    typedef bg::model::d2::point_xy<double> point;",
			"    typedef bg::model::polygon<point> polygon;",
			"    //入力",
			"    polygon poly;",
			"    poly.outer().push_back({0,0});",
			"    poly.outer().push_back({0,1});",
			"    poly.outer().push_back({1,0});",
			"    poly.outer().push_back({1,1});",
			"    poly.outer().push_back({0.5,1.5});",
			"    // poly.outer().push_back({0,0});",
			"",
			"    //出力先.",
			"    polygon hull;",
			"    bg::convex_hull(poly, hull);",
			"",
			"    //デバッグ",
			"    EL(bg::dsv(poly))",
			"    EL(bg::dsv(hull))",
			"",
			"    auto h = hull.outer();",
			"    EL(h.size())",
			"    EL(h[0].x())",
			"    for(auto p:hull.outer()){",
			"        ES(p.x()) EL(p.y())",
			"    }",
			"",
			" 接触判定．",
			"bg::model::linestring<point> linest{{s.fi, s.se}, {t.fi,t.se}};",
			"bool cross = false;",
			"if(!bg::intersects(linest, poly.outer())){",
			"END(hypot(s.fi-t.fi, s.se-t.se))",
			"}",
			"*/"
		],
		"description": "boost 計算幾何　凸包",
	},

	"boost/miller_rabin": {
		"scope": "cpp",
		"prefix": "boost　miller rabin sosuu hanntei ",
		"body": [
			"#include <boost/multiprecision/cpp_int.hpp>",
			"#include <boost/multiprecision/miller_rabin.hpp>",
			"#include <boost/random/mersenne_twister.hpp>",
			"namespace mp = boost::multiprecision;",
			"boost::random::mt19937 gen;",
			"for (int i = 2; i < 20; ++i) {",
			"    bool is_prime = mp::miller_rabin_test(i, 25, gen);//判定する数，試行回数",
			"}",
		],
		"description": "ミラーラビン法素数判定",
	},

	"boost/multiprecision/float": {
		"scope": "cpp",
		"prefix": "boost float multiprecision",
		"body": [
			"#include <boost/multiprecision/cpp_dec_float.hpp>",
			"namespace mp = boost::multiprecision;",
			"/*",
			"https://boostjp.github.io/tips/multiprec-float.html",
			"    mp::cpp_dec_float_100 a,b;",
			"",
			"    cpp_dec_float_50 x;",
			"    cpp_dec_float_100 y;",
			"",
			"    //ユーザー定義．桁数が1000桁で指数部が64bitで表される型",
			"    typedef mp::number<mp::cpp_dec_float<1000, std::int64_t> > cpp_dec_float_1000_64exp;",
			"",
			"    -----OpenGMPによる多倍長------",
			"    #include <boost/multiprecision/gmp.hpp>",
			"    mpf_float_50",
			"    mpf_float_100",
			"    mpf_float_500",
			"    mpf_float_1000",
			"    mpf_float",
			"",
			"    -----小数->文字列",
			"    cpp_dec_float_50 x = 3.14;",
			"    x.str();",
			"",
			"    -----文字列->小数",
			"    cpp_dec_float_100 x(\"3.14\");// char配列から変換",
			"    cpp_dec_float_100 y(std::string(\"3.14\"));",
			"    x.assign(\"3.14\");",
			"",
			"    -----劣精度変換.優精度なら暗黙変換",
			"    cpp_dec_float_50 f50 = static_cast<cpp_dec_float_50>(cpp_dec_float_100(3.14));",
			"ABC169C",
			"*/",
		],
		"description": "多倍長浮動小数点数",
	},

	"boost/multiprecision/int": {
		"scope": "cpp",
		"prefix": "boost int multiprecision",
		"body": [
			"#include <boost/multiprecision/cpp_int.hpp>",
			"namespace mp = boost::multiprecision;",
			"/*",
			"    //メモリの許す限り無限",
			"    mp::cpp_int x = 1;",
			"    mp::int128_t 1e36",
			"    mp::int256_t 1e70",
			"    mp::int512_t 1e150",
			"    mp::int1024_t 1e300",
			"",
			"    文字列->整数",
			"    cpp_int x(\"123\");",
			"    x.assign(\"123\");",
			"",
			"    整数->文字列",
			"    string s = x.str();",
			"    x.str(0, std::ios_base::oct,hex,)",
			"",
			"    劣型変換",
			"    int128_t i128 = static_cast<int128_t>(i256)",
			"*/"
		],
		"description": "多倍長整数",
	},

	"boost/string": {
		"scope": "cpp",
		"prefix": "boost replace",
		"body": [
			"#include <boost/algorithm/string.hpp>",
			"#include <boost/algorithm/string/replace.hpp>",
			"#include <boost/algorithm/string/find.hpp>",
			"//boost::to_upper(S);",
			"//boost::algorithm::replace_all(S, \"Hello\", \"Goodbye\");",
			"//boost::algorithm::replace_first(S, \"Hello\", \"Goodbye\");",
			"//boost::algorithm::replace_last(S, \"Hello\", \"Goodbye\");",
			"//auto it = boost::algorithm::find_first(S, \"a\"); it.begin(), it.end();",
			"//boost::algorithm::erase(S, \"Hello\");",
			"//boost::algorithm::erase_head(S, 6);",
			"//https://www.boost.org/doc/libs/1_81_0/doc/html/string_algo/usage.html#id-1.3.3.5.6"

		],
		"description": "boost replace, find, to_upper",
	},

	"builtin": {
		"scope": "cpp",
		"prefix": "builtin",
		"body": [
			"//1の数",
			"//__builtin_popcount()",
			"//__builtin_popcountll()",
			"//下から初めて1が現れる場所(1-indexed)",
			"//__builtin_ffs()",
			"//__builtin_ffsll()",
			"//先頭に何個0があるか",
			"//__builtin_clz()",
			"//__builtin_clzll()",
			"//末尾に何個0があるか",
			"//__builtin_ctz()",
			"//__builtin_ctzll()",
		],
		"description": "builtin set",
	},

	"dfs_grid": {
		"scope": "cpp",
		"prefix": "dfs_grid",
		"body": [
			"int dx[4] = {1, 0, -1, 0};",
			"int dy[4] = {0, 1, 0, -1};",
			"",
			"int h,w; cin>>h>>w;",
			"vector<string> S(h);",
			"for(int i=0;i<h;i++) cin>>S[i];",
			"",
			"int sx=0,sy=0;",
			"int gx=0,gy=0;",
			"for(int i=0;i<h;i++) for(int j=0;j<w;j++){",
			"    if(G[i][j]=='S') sx=i, sy=j;",
			"    if(G[i][j]=='G') gx=i, gy=j;",
			"}",
			"",
			"vector<vector<ll>> dist(h,vector<ll>(w,LINF));",
			"auto dfs = [&](auto dfs, int px, int py)->void{",
			"    for(int i=0;i<4;i++){",
			"        int nx = px+dx[i];",
			"        int ny = py+dy[i];",
			"        if(0<=nx&&nx<h&&0<=ny){//&&ny<w&&G[nx][ny]!='#'){",
			"            if(dist[px][py]+1<dist[nx][ny] && dist[px][py]+1<=dist[gx][gy]){",
			"                dist[nx][ny] = dist[px][py]+1;",
			"                dfs(dfs, nx,ny);",
			"            }",
			"        }",
			"    }",
			"};",
			"",
			"dist[sx][sy] = 0;",
			"dfs(dfs, sx, sy);",
			
			"cout<<dist[gx][gy]<<endl;",
		],
		"description": "dfs_grid",
	},

	"DP/edit_distance": {
		"scope": "cpp",
		"prefix": "edit distance",
		"body": [
			"#include \"dp/edit_distance.hpp\"",
			"/*",
			"string S = \"abc\", T = \"abcd\";",
			"EditDistance ed;",
			"int dist = ed.solve(S,T);",
			"int dist = ed.solve(S,T,INSERT_COST, DELETE_COST, CHANGE_COST);",
			"vector<array<int,3>> op = ed.recovery();",
			"// {Sの操作文字，Tの操作文字，操作番号}がdist個",
			"1:削除 2:挿入 3:変更",
			"復元時，挿入削除による添え字注．",
			"https://o-treetree.hatenablog.com/entry/DPL1E",
			"*/"
		],
		"description": "編集距離．レーベンシュタイン距離",
	},

	"DP/LCP": {
		"scope": "cpp",
		"prefix": "dp lcp",
		"body": [
			"#include \"dp/lcp.hpp\"",
			"/*",
			"    string S = \"abc\";",
			"    string T = \"abdabc\";",
			"    LCP lcp(S,T);",
			"    rep(i,S.size()) EL(lcp[i])",
			"    ABC141E",
			"*/",
		],
		"description": "S[i], T[j]からの最長共通連続部分列を求める",
	},

	"DP/LCS": {
		"scope": "cpp",
		"prefix": "LCS",
		"body": [
			"#include \"dp/lcs.hpp\"",
			"//string s,t;",
			"//vector<int> s,t; cin>>s>>t;",
			"cin>>s>>t;",
			"LCS lcs(s,t);",
			"EL(lcs.len)//長さ",
			"EL(lcs.idS)//id",
			"EL(lcs.idT)",
			"EL(lcs.lcs)//一例",
			"//EDPC F"
		],
		"description": "LCS 最長共通部分列（非連続含む）",
	},

	"DP/LIS": {
		"scope": "cpp",
		"prefix": "LIS",
		"body": [
			"#include \"dp/lis.hpp\"",
			"// vector<int> A = {1,2,3,2,1};",
			"// LIS lis(A, true);",
			"// EL(lis.size())",
			"// EL(lis.example)",
			"// EL(lis.example_ids)",
			"",
			"// string s = \"12321\";",
			"// LIS lis2(s, true);",
			"// EL(lis2.example)"
		],
		"description": "LIS 最長増加部分列",
	},

	"dsu": {
		"scope": "cpp",
		"prefix": "dsu",
		"body": [
			"struct dsu{",
			"    int N;",
			"    vector<int> parent, rank, size_;",
			"    dsu(int n){",
			"        N=n;",
			"        parent.resize(n);",
			"        rank.resize(n);",
			"        size_.resize(n,1);",
			"        for(int i=0;i<n;i++) parent[i] = i;",
			"    }",
			"",
			"    int leader(int x){",
			"        if(parent[x]==x) return x;",
			"        else return parent[x]=leader(parent[x]);",
			"    }",
			"",
			"    int merge(int x, int y){",
			"        x = leader(x);",
			"        y = leader(y);",
			"        if(x==y) return x;",
			"",
			"        if(rank[x]<rank[y]){",
			"            parent[x] = y;",
			"            size_[y] += size_[x];",
			"            return y;",
			"        }",
			"        else if(rank[x]>rank[y]){",
			"            parent[y] = x;",
			"            size_[x] += size_[y];",
			"            return x;",
			"        }",
			"        else{",
			"            parent[x] = y;",
			"            size_[y] += size_[x];",
			"            rank[y]++;",
			"            return y;",
			"        }",
			"    }",
			"",
			"    bool same(int x, int y){",
			"        x = leader(x);",
			"        y = leader(y);",
			"        return x==y;        ",
			"    }",
			"",
			"    int size(int x){",
			"        x = leader(x);",
			"        return size_[x];",
			"    }",
			"",
			"    vector<vector<int>> groups(){",
			"        vector<int> Leader(N), group_size(N);",
			"        for(int i=0;i<N;i++){",
			"            Leader[i] = leader(i);",
			"            group_size[Leader[i]]++;",
			"        }",
			"        vector<vector<int>> result(N);",
			"        for(int i=0;i<N;i++){",
			"            result[i].reserve(group_size[i]);",
			"        }",
			"        for(int i=0;i<N;i++){",
			"            result[Leader[i]].push_back(i);",
			"        }",
			"        result.erase(std::remove_if(result.begin(), result.end(),[&](const std::vector<int>& v) { return v.empty(); }),result.end());",
			"        return result;",
			"    }",
			"};",
			"",
			"",
			"dsu DSU(10);",
			"",
			"if(!DSU.same(0,1)) cout<<\"0 1 different\"<<endl;",
			"if(!DSU.same(0,7)) cout<<\"0 7 different\"<<endl;",
			"",
			"DSU.merge(0,1);",
			"DSU.merge(0,2);",
			"DSU.merge(0,3);",
			"DSU.merge(8,9);",
			"",
			"if(DSU.same(0,1)) cout<<\"0 1 same\"<<endl;",
			"if(!DSU.same(0,7)) cout<<\"0 7 different\"<<endl;",
			"",
			"for(int i=0;i<10;i++) cout<<DSU.size(i)<<\" \";",
			"cout<<endl;",
			"",
			"auto groups = DSU.groups();",
			"for(int i=0;i<groups.size();i++){",
			"    for(int j=0;j<groups[i].size();j++) cout<<groups[i][j]<<\" \";",
			"    cout<<endl;",
			"}",

		],
		"description": "original dsu",
	},

	"dx:dy": {
		"scope": "cpp",
		"prefix": "dx:dy",
		"body": [
			"//DRUL  SENW",
			"int dx[4] = {1, 0, -1, 0};",
			"int dy[4] = {0, 1, 0, -1};",
			"",
			"auto inGrid = [&](int nx, int ny){",
			"    if(0<=nx&&nx<H&&0<=ny&&ny<W) return true;",
			"    return false;",
			"};"
		],
		"description": "dx:dy",
	},

	"Eigen/Polynominals": {
		"scope": "cpp",
		"prefix": "eigen polynominals",
		"body": [
			"#include \"math/matrix/eigen_template.hpp\"",
			"#include <eigen3/unsupported/Eigen/Polynomials>",
			"/*",
			"ll N; cin>>N;",
			"Eigen::Vector<double, Eigen::Dynamic> coeff;",
			"coeff.resize(N);",
			"cin>>coeff;",
			"reverse(ALL(coeff));// c[0] + c[1]*x + c[2]*x^2 + ...",
			"",
			"// coef -> roots",
			"Eigen::PolynomialSolver<double, Eigen::Dynamic> solver;",
			"solver.compute(coeff);",
			"const Eigen::PolynomialSolver<double, Eigen::Dynamic>::RootsType &roots = solver.roots();",
			"rep(i,roots.size()){ ES(roots[i].real()) EL(roots[i].imag()) }",
			"",
			"//roots -> coef",
			"Eigen::Vector<complex<double>, Eigen::Dynamic> poly;",
			"Eigen::roots_to_monicPolynomial(roots, poly);",
			"rep(i,poly.size()){ ES(poly[i].real()) EL(poly[i].imag()) }",
			"*/"
		],
		"description": "eigen 多項式<->根",
	},

	"Graph/graph_template": {
		"scope": "cpp",
		"prefix": "graph template",
		"body": [
			"#include \"graph/graph_template.hpp\"",
			"/*",
			"   ll N,M; cin>>N>>M;",
			"   Edges<int> E = readE<int>(M, -1, true);//weighted?",
			"   Graph<int> G(N, E, false, false);//directed? reverse?",
			"   //Graph<int> G(N); G.read(M, -1, true, true);",
			"*/"
		],
		"description": "graph template",
	},

	"Graph/mst/kruskal": {
		"scope": "cpp",
		"prefix": "kruskal",
		"body": [
			"#include \"graph/mst/kruskal.hpp\"",
			"",
			"    ll N; cin>>N;",
			"    ll M; cin>>M;",
			"",
			"    Edges<ll> E = readE<ll>(M, 0, true);",
			"    Graph<ll> G(N, E, true);",
			"",
			"    Kruskal<ll> kr(N);",
			"    kr.solve(E);",
			"",
			"    PL(kr.total)",
			"    EL(E[0].used)",
		],
		"description": "クラスカル法(最小辺UF)",
	},

	"Graph/mst/prim": {
		"scope": "cpp",
		"prefix": "prim",
		"body": [
			"#include \"graph/mst/prim.hpp\"",
			"/*",
			"    ll N; cin>>N;",
			"    ll M; cin>>M;",
			"    ll s = 0;",
			"",
			"    Edges<ll> E = readE<ll>(M, 0, true);",
			"    Graph<ll> G(N, E, false);",
			"",
			"    Prim<ll> prim(N, INF);",
			"    prim.solve(G, s);",
			"    PL(prim.total)",
			"*/"
		],
		"description": "プリム法(ダイクストラ)",
	},

	"Graph/others/cycle_detection": {
		"scope": "cpp",
		"prefix": "cycle detection",
		"body": [
			"#include \"graph/others/cycle_detection.hpp\"",
			"/*",
			"    ll N,M; cin>>N>>M;",
			"    auto E = readE<int>(M, -1, false);",
			"    Graph<int> G(N, E, false);",
			"",
			"    CycleDetection<int> Cycle(N, true);//有向?",
			"    Cycle.undirectedCheckLoop(G);//loop上かどうか調べる",
			"    Cycle.findOneLoop(G);//一つ閉路探す",
			"    EL(Cycle.inLoop)",
			"    EL(Cycle.path)",
			"    EL(Cycle.edges)",
			"*/",
		],
		"description": "閉路検出 cycle detection",
	},

	"Graph/others/lowlink": {
		"scope": "cpp",
		"prefix": "lowlink",
		"body": [
			"#include \"graph/others/lowlink.hpp\"",
			"/*",
			"   ll N,M; cin>>N>>M;",
			"   Edges<int> E = readE<int>(M, -1, false);//weighted?",
			"   Graph<int> G(N, E, false, false);//directed? reverse?",
			"   LowLink link(G);",
			"   ",
			"   EL(bridges) // vector<Pii> : from, to",
			"   EL(bridgeIds)// vectorMint> id",
			"   EL(aps) //関節点 articulation points",
			"",
			"   h ttps://algo-logic.info/bridge-lowlink/",
			"   abc075c",
			"*/"
		],
		"description": "橋となる辺を求める",
	},

	"Graph/others/periodic_graph": {
		"scope": "cpp",
		"prefix": "periodic graph",
		"body": [
			"#include \"graph/others/periodic_graph.hpp\"",
			"/*",
			"ll N,M; cin>>N>>M;",
			"Edges<int> E = readE<int>(M, -1, false);//weighted?",
			"Graph<int> G(N, E, true, false);//directed? reverse?",
			"Graph<int> inG(N, E, true, true);//directed? reverse?",
			"PeriodicGraph<int> pg;",
			"pg.build(N, G, inG);",
			"// pg.Proceed(start, k)",
			"vector<pair<int, int>> loopIdx;//[頂点iが属する閉路のid,閉路内id].属さないなら-1",
			"vector<vector<int>> loops;//実際に要素格納.[i][j]:=i番目のループのj番目の頂点",
			"vector<pair<int,CostT>> nearestLoop;//{最近ループ上頂点, そこまでの距離}",
			"*/",
		],
		"description": "周期性を持った移動．内部ダブリング",
	},

	"Graph/shortest_path/bellman_ford": {
		"scope": "cpp",
		"prefix": "bellman_ford",
		"body": [
			"#include \"graph/shortest_path/bellman_ford.hpp\"",
			"/*",
			"    ll N; cin>>N;",
			"    ll M; cin>>M;",
			"",
			"    Edges<int> E = readE<int>(M, -1, false);",
			"",
			"    BellmanFord<int> bf(N, INF);",
			"    bool infinite = bf.solve(E, 0, true);",
			"",
			"    EL(bf.dist)",
			"    EL(bf.find_path(N-1))",
			"    EL(bf.find_edges(N-1))",
			"*/"
		],
		"description": "ベルマンフォード",
	},

	"Graph/shortest_path/bfs": {
		"scope": "cpp",
		"prefix": "bfs",
		"body": [
			"#include \"graph/shortest_path/bfs.hpp\"",
			"/*",
			"    ll N; cin>>N;",
			"    ll M; cin>>M;",
			"",
			"    Edges<int> E = readE<int>(M, -1, false);//辺数，index, weight",
			"    Graph<int> G(N, E, false);//頂点数，Edges, 有向",
			"",
			"    BFS<int> bfs(N, INF);//頂点数，初期距離",
			"    bfs.solve(G, 0, 0, false);//G, start, goal, 通り数える",
			"",
			"    EL(bfs.dist)",
			"    EL(bfs.find_path(N-1))",
			"    EL(bfs.find_edges(N-1))",
			"    EL(bfs.cnt)",
			"    BFS<int, mint> <-cntに用いる型",
			"*/"

		],
		"description": "bfs 最短距離",
	},

	"Graph/shortest_path/dijkstra": {
		"scope": "cpp",
		"prefix": "dijkstra",
		"body": [
			"#include \"graph/shortest_path/dijkstra.hpp\"",
			"/*",
			"    ll N; cin>>N;",
			"    ll M; cin>>M;",
			"",
			"    Edges<int> E = readE<int>(M, -1, false);//辺数，index, weight",
			"    Graph<int> G(N, E, false);//頂点数，Edges, 有向",
			"",
			"    Dijkstra<int> di(N, INF);//頂点数，初期距離",
			"    di.solve(G, 0, 0, false);//G, start, goal, 通り数える",
			"",
			"    EL(di.dist)",
			"    EL(di.find_path(N-1))",
			"    EL(di.find_edges(N-1))",
			"    EL(di.cnt)",
			"    Dijkstra<int, mint> <-cntに用いる型",
			"*/"

		],
		"description": "ダイクストラ dijkstra",
	},

	"Graph/shortest_path/warshall_floyed": {
		"scope": "cpp",
		"prefix": "warshall froyed",
		"body": [
			"#include \"graph/shortest_path/warshall_floyed.hpp\"",
			"",
			"/*",
			"    ll N; cin>>N;",
			"    ll M; cin>>M;",
			"",
			"    Edges<int> E = readE<int>(N, -1, false);",
			"",
			"    WarshallFloyed<int> wf(N, E, INF, true);",
			"    wf.solve();",
			"",
			"    rep(i,N) EL(wf.dist[i])",
			"",
			"    EL(wf.find_path(0, N-1))",
			"    EL(wf.find_edges(0, N-1))",
			"*/",

		],
		"description": "ワーシャルフロイド",
	},

	"Graph/tree/complete_binary_tree": {
		"scope": "cpp",
		"prefix": "complete binary tree",
		"body": [
			"#include \"graph/tree/complete_binary_tree.hpp\"",
			"/*",
			"   CompleteBinaryTree cbt;",
			"   cbt.SetN(N);//頂点数Nの場合",
			"   //cbt.SetDepth(D);//深さD",
			"",
			"   // 頂点は1-index",
			"   ll n = cbt.CountDist(v, dist);//vから距離dの頂点数",
			"   ll n = cbt.CountDescendants(v);//vの子孫数",
			"   ll n = cbt.CountDescendantsDist(v, dist);//子孫の中で距離distの頂点数",
			"",
			"   //depth, posは0-index",
			"   auto [d, pos] = cbt.GetPosition(v);",
			"   ll v = cbt.GetIndex(d, pos);",
			"   abc321e",
			"*/",
		],
		"description": "",
	},

	"Graph/tree/euler_tour/directed_tree_dist_query": {
		"scope": "cpp",
		"prefix": "directed tree dist query",
		"body": [
			"#include \"graph/tree/euler_tour/directed_tree_dist_query.hpp\"",
			"/*",
			"   ll N; cin>>N;",
			"   ll Q; cin>>Q;",
			"   Edges<ll> E = readE<ll>(N-1, -1, false);//weighted?",
			"   Graph<ll> G(N, E, false);//directed?",
			"",
			"   DirectedTreeDistQuery<ll> dtdq(N, G, 0);",
			"   for(const auto& e:E){",
			"   dtdq.set(e.from, e.to, d1);",
			"   dtdq.add(e.to, e.from, d2);",
			"   ",
			"   PL(dtdq.query(x, y))",
			"   joisc2010/highway",
			"*/",
		],
		"description": "木の距離計算．往復でコストが違うときも使える．",
	},

	"Graph/tree/euler_tour/euler_tour": {
		"scope": "cpp",
		"prefix": "euler tpur",
		"body": [
			"#include \"graph/tree/euler_tour/euler_tour.hpp\"",
			"/*",
			"   ll N; cin>>N;",
			"   Edges<ll> E = readE<ll>(N-1, -1, true);//weighted?",
			"   Graph<ll> G(N, E, false);//directed?",
			"   EulerTour<ll> et(N, G, 0);//root",
			"   EulerTour<ll> et(N, G, 0, true, true);//root, mid, out",
			"   et.lca(x,y);",
			"   et.size()",
			"",
			"   vector<int> in;//頂点iを始めて訪れた時刻",
			"   vector<int> out;//頂点iを出た時刻",
			"   vector<int> depth;//depth[i]:=頂点iの深さ",
			"   vector<int> parent;//parent[i]:=頂点iの親．",
			"   vector<vector<int>> children;//children[i]:=頂点iの直属の子",
			"   vector<int> numOfChildren;//子孫の数．",
			"   vector<T> dist;//dist[i]:=根から頂点iまでのコスト",
			"   vector<int> order;//order[i]:=時刻iに訪れた頂点",
			"   vector<int> dep;//dep[i]:=時刻iの深さ",
			"*/",
		],
		"description": "オイラーツアー．",
	},

	"Graph/tree/euler_tour/tree_dist_query": {
		"scope": "cpp",
		"prefix": "tree dist query",
		"body": [
			"#include \"graph/tree/euler_tour/tree_dist_query.hpp\"",
			"/*",
			"   ll N; cin>>N;",
			"   Edges<ll> E = readE<ll>(N-1, -1, true);//weighted?",
			"   Graph<ll> G(N, E, false);//directed?",
			"   TreeDistQuery<ll> tdq(N, G, 0);//root",
			"   ",
			"",
			"   //edge 辺クエリ",
			"   for(auto& e:E) tdq.set(e.from, e.to, e.cost);",
			"   tdq.set(u,v,w);",
			"   tdq.add(u,v,w);",
			"   tdq.query(u,v);//u->vへ行く距離（コスト合計）",
			"   //node 頂点クエリ",
			"   tdq.set(p, w);",
			"   tdq.add(p,w);",
			"   tdq.query(p);//pを含む部分木の合計",
			"",
			"   EL(tdq.et.in[x])",
			"   EL(tdq.et.out[x])",
			"   EL(tdq.et.depth[x])",
			"   EL(tdq.et.numOfChildren[x])",
			"   EL(tdq.et.parent[x])",
			"   EL(tdq.et.lca(u,v))",
			"   ABC294G",
			"*/",
		],
		"description": "",
	},

	"Graph/tree/hld/hld": {
		"scope": "cpp",
		"prefix": "hld",
		"body": [
			"#include \"graph/tree/hld/hld.hpp\"",
			"/*",
			"   ll N; cin>>N;",
			"   Edges<int> E = readE<int>(N-1, -1, true);//weighted?",
			"   Graph<int> G(N, E, false);//directed?",
			"   HLD hld(N, G, 0);",
			"   RSQ<ll> seg(N);",
			"",
			"   for(auto& e:E){",
			"      //更新．a==bの時もあるので，1点更新の場合は気を付ける．",
			"      //辺の場合はb-1, 頂点ならa",
			"      auto update = [&](int a, int b)->void {//a:in[u]+edge, in[v]+1",
			"         if(a!=b) seg.set(b-1, e.cost);",
			"      };",
			"      hld.add(e.from, e.to, update, true);",
			"   }",
			"",
			"   ll u, v;",
			"   cin>>u>>v;",
			"   u--, v--;",
			"   auto unit = 0LL;//単位元",
			"   auto prod = [&](int a, int b)->ll {return seg.prod(a, b);};//同成分の積．//a:in[u]+edge, in[v]+1",
			"   auto merge = [&](ll a, ll b)->ll {return a + b;};//異成分同士の積",
			"   auto merge2 = [&](ll a, ll b)->ll {return a + b;};//異成分同士の積．一番最後の操作",
			"   PL(hld.query(u, v, unit, prod, merge, merge2, true))",
			"   abc294G6",
			"   iroha2019-day2 K2",
			"*/",
		],
		"description": "HL分解．木のクエリ．特にパスやmin,maxが得意",
	},

	"Graph/tree/LCA_Doubling": {
		"scope": "cpp",
		"prefix": "LCA Doubling",
		"body": [
			"#include \"graph/tree/LCA_doubling.hpp\"",
			"/*",
			"    ll N; cin>>N;",
			"    Edges<int> E = readE<int>(N-1, -1, false);//weighted",
			"    Graph<int> G(N, E, false);//directed",
			"",
			"    LCADoubling tree(N, G, 0);//root",
			"",
			"    EL(tree.lca(0,2));",
			"    EL(tree.dist(0,2));",
			"",
			"    EL(tree.depth[0])",
			"    EL(tree.numOfChildren[0])",
			"    EL(tree.parent[0])",
			"    EL(tree.dist[0])",
			"*/"
		],
		"description": "LCA ダブリング　初期化(N), lca(logN), climb(logN), distance(logN)",
	},

	"Graph/tree/LCA_RMQ": {
		"scope": "cpp",
		"prefix": "LCA RMQ",
		"body": [
			"#include \"graph/tree/LCA_RMQ.hpp\"",
			"/*",
			"    ll N; cin>>N;",
			"    Edges<int> E = readE<int>(N-1, -1, false);//weighted",
			"    Graph<int> G(N, E, false);//directed",
			"    LCA_RMQ tree(N, G, 0);//root",
			"",
			"   EL(tree.lca(0,4))//共通祖先id",
			"   EL(tree.size())",
			"*/"
		],
		"description": "LCA RMQ 初期化(NlogN), lca(1), distance(1)",
	},

	"Graph/tree/rerooting_dp": {
		"scope": "cpp",
		"prefix": "RerootingDP",
		"body": [
			"#include \"graph/tree/rerooting_dp.hpp\"",
			"/*",
			"   ll N; cin>>N;",
			"   Edges<ll> E = readE<ll>(N-1, -1, false);//weighted?",
			"   Graph<ll> G(N, E, false);//directed?",
			"   ",
			"   using EdgeT = ll;",
			"   using VertexT = ll;",
			"   auto Merge = [&](EdgeT a, EdgeT b)->EdgeT {",
			"      return max(a,b);",
			"   };",
			"   auto El = [&](int p, bool canAffectSelf = false)->EdgeT {",
			"      if(canAffectSelf) return 0;",
			"      return 0;",
			"   };",
			"   auto PE = [&](VertexT v, const Edge<ll>& e)->EdgeT {",
			"      return v + e.cost;",
			"   };",
			"   auto PV = [&](EdgeT e, int p)->VertexT {",
			"      return e;",
			"   };",
			"   ",
			"   RerootingDP<EdgeT, VertexT> rdp;",
			"   rdp.build(N, G, 0, Merge, El, PE, PV);",
			"   auto dp = rdp.reroot(G, Merge, El, PE, PV);",
			"",
			"vertex:その頂点を根とした値を考えるとき",
			"edge:根以外の木の一部にするとき．",
			"typ90003, abc222f, edpc_v",
			"abc220f:pair載せる",
			"*/"
		],
		"description": "全方位木DP",
	},

	"Graph/tree/rooted_tree": {
		"scope": "cpp",
		"prefix": "rooted tree",
		"body": [
			"#include \"graph/tree/rooted_tree.hpp\"",
			"/*",
			"   ll N,M; cin>>N>>M;",
			"   Edges<int> E = readE<int>(M, -1, false);//weighted?",
			"   Graph<int> G(N, E, false);//directed?",
			"   //Graph<int> G(N); G.read(M, -1, true, true);",
			"",
			"   RootedTree rt(N, G, 0);",
			"",
			"   EL(rt.depth)",
			"   EL(rt.parent)",
			"   EL(rt.numOfDescendants)",
			"   rep(i,N) EL(rt.children[i])",
			"   EL(rt.farestDescendant)",
			"   parent[root]=root",
			"   //Edgeは親->子が含まれていれば,有向でも無向でもOK",
			"*/"
		],
		"description": "graph rooted tree 根つき木",
	},

	"Graph/tree/tree_diameter": {
		"scope": "cpp",
		"prefix": "tree diameter",
		"body": [
			"#include \"graph/tree/tree_diameter.hpp\"",
			"/*",
			"    ll N; cin>>N;",
			"    Edges<int> E = readE<int>(N-1, -1, false);",
			"    Graph<int> G(N, E, false);",
			"    TreeDiameter tree(N, G, INF, false);//needDistFromR?",
			"    ES(tree.l) EL(tree.r)",
			"    EL(tree.Diameter)",
			"*/"
		],
		"description": "tree diameter 木の直径と端点，距離",
	},

	"lower_bound extention": {
		"scope": "cpp",
		"prefix": "lower_bound reverse",
		"body": [
			"template<typename T, typename Iterator>",
			"Iterator rlower_bound(Iterator first, Iterator last, T value){",
			"    return lower_bound(first, last, value, [](const T& a, const T& b){return a>b;});",
			"}",
			"template<typename T, typename Iterator>",
			"Iterator rupper_bound(Iterator first, Iterator last, T value){",
			"    return upper_bound(first, last, value, [](const T& a, const T& b){return a>b;});",
			"}",
			"// auto it = rlower_bound(RALL(A), a);",
		],
		"description": "lower_bound の逆方向．以下，未満を探せる",
	},

	"Math/fps": {
		"scope": "cpp",
		"prefix": "fps",
		"body": [
			"#include \"math/fps.hpp\"",
			"using FPS = FormalPowerSeries<mint>;",
			"using SFPS = V<pair<int, mint>>;",
		],
		"description": "fps",
	},

	"Math/Kth_element": {
		"scope": "cpp",
		"prefix": "kth element",
		"body": [
			"#include \"math/Kth_element.hpp\"",
			"#include <boost/multiprecision/cpp_int.hpp>",
			"/*",
			"namespace mp = boost::multiprecision;",
			"0-indexed",
			"60!=82桁<512bit",
			"auto res = kth_element<boost::multiprecision::int1024_t>(string(A,'a')+string(B,'b'), K-1)",
			"auto res = kth_element<boost::multiprecision::int1024_t>(A, K-1)",
			"*/"
		],
		"description": "辞書順k番目の値を返す．O(NMlogM)．N=長さ，M=種類数．多倍長ならその分も．",
	},

	"Math/matrix/matrix": {
		"scope": "cpp",
		"prefix": "matrix",
		"body": [
			"#include \"math/matrix/matrix.hpp\"",
			"/*",
			"Matrix<mint> m(H,W)",
			"m.determinant()",
			"累乗は^",
			"*/"
		],
		"description": "行列演算",
	},

	"Math/sum_of_K_products": {
		"scope": "cpp",
		"prefix": "math sum_of_K_products",
		"body": [
			"#include \"math/sum_of_products.hpp\"",
			"/*",
			"ll ans = sum_of_K_products(A, K);",
			"-> Σ(ai*aj*...*ak)を計算．",
			"*/",
		],
		"description": "",
	},

	"Mex": {
		"scope": "cpp",
		"prefix": "Mex",
		"body": [
			"#include \"structure/others/mex.hpp\"",
			"/*",
			"Mex<ll> mex;",
			"mex.insert(x);",
			"mex.erase(x);",
			"mex.contains(x);",
			"mex.mex();",
			"abc330e"
			"*/"
		],
		"description": "Mex segtree",
	},

	"MexEbi": {
		"scope": "cpp",
		"prefix": "Mex ebi",
		"body": [
			"#include \"structure/others/mex_ebi.hpp\"",
			"/*",
			"Mex mex;//always int",
			"mex.insert(x);",
			"mex.mex();",
			"mex.contains();",
			"*/"
		],
		"description": "Mex by えびちゃん",
	},

	"modint": {
		"scope": "cpp",
		"prefix": "mint",
		"body": [
			"template< int mod >",
			"struct ModInt {",
			"  int x;",
			"",
			"  ModInt() : x(0) {}",
			"",
			"  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}",
			"",
			"  ModInt &operator+=(const ModInt &p) {",
			"    if((x += p.x) >= mod) x -= mod;",
			"    return *this;",
			"  }",
			"",
			"  ModInt &operator-=(const ModInt &p) {",
			"    if((x += mod - p.x) >= mod) x -= mod;",
			"    return *this;",
			"  }",
			"",
			"  ModInt &operator*=(const ModInt &p) {",
			"    x = (int) (1LL * x * p.x % mod);",
			"    return *this;",
			"  }",
			"",
			"  ModInt &operator/=(const ModInt &p) {",
			"    *this *= p.inverse();",
			"    return *this;",
			"  }",
			"",
			"  ModInt operator-() const { return ModInt(-x); }",
			"",
			"  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }",
			"",
			"  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }",
			"",
			"  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }",
			"",
			"  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }",
			"",
			"  bool operator==(const ModInt &p) const { return x == p.x; }",
			"",
			"  bool operator!=(const ModInt &p) const { return x != p.x; }",
			"",
			"  ModInt inverse() const {",
			"    int a = x, b = mod, u = 1, v = 0, t;",
			"    while(b > 0) {",
			"      t = a / b;",
			"      swap(a -= t * b, b);",
			"      swap(u -= t * v, v);",
			"    }",
			"    return ModInt(u);",
			"  }",
			"",
			"  ModInt pow(int64_t n) const {",
			"    ModInt ret(1), mul(x);",
			"    while(n > 0) {",
			"      if(n & 1) ret *= mul;",
			"      mul *= mul;",
			"      n >>= 1;",
			"    }",
			"    return ret;",
			"  }",
			"",
			"  friend ostream &operator<<(ostream &os, const ModInt &p) {",
			"    return os << p.x;",
			"  }",
			"",
			"  friend istream &operator>>(istream &is, ModInt &a) {",
			"    int64_t t;",
			"    is >> t;",
			"    a = ModInt< mod >(t);",
			"    return (is);",
			"  }",
			"",
			"  static int get_mod() { return mod; }",
			"};",
			"",
			"using Modint = ModInt< MOD >;"
		],
		"description": "original::modint",
	},

	"mod逆元": {
		"scope": "cpp",
		"prefix": "mod_inv",
		"body": [
			"ll mod_inv(ll x, ll mod=0){",
			"    ll m = mod-2;",
			"    ll result = 1;",
			"    ll tmp = x%mod;",
			"    while(m){",
			"        if(m&1) result *= tmp;",
			"        result %= mod;",
			"        tmp = tmp*tmp;",
			"        tmp %= mod;",
			"        m /= 2;",
			"    }",
			"    return result;",
			"}",
			"",
			// ll inv = mod_inv(2, MOD);
		],
		"description": "mod逆元",
	},

	"n進数表示": {
		"scope": "cpp",
		"prefix": "nshinnsuu",
		"body": [
			"vector<ll> digit(ll n, ll base=2, bool reverse_ = true){",
			"   assert(n>=0);",
			"   vector<ll> ret;",
			"   if(n==0){",
			"      ret.push_back(0);",
			"      return ret;",
			"   }",
			"   ll sig = 1;",
			"   ll d = abs(base);",
			"   while(n){",
			"      ret.push_back((n*sig)%d);",
			"      if(ret.back()<0) ret.back() += d;",
			"      n -= ret.back() * sig;",
			"      n /= d;",
			"      sig *= base / abs(base);",
			"   }",
			"   if(reverse_) reverse(ret.begin(), ret.end());",
			"   return ret;",
			"}",
			"/* 負の底ok.abc105 c beat参照",
			"digit(6, 2) = {1,1,0} = 4+2",
			"digit(6, 2, false) = {0,1,1} = 2 + 4  ",
			"digit(6, -2) = {1,1,0,1,0} = 16 -8  - 2",
			"*/"
		],
		"description": "n進数表示",
	},

	"Others/Mo's algorithm": {
		"scope": "cpp",
		"prefix": "mo",
		"body": [
			"#include \"others/mo.hpp\"",
			"/*",
			"    Mo mo(N);//配列要素数",
			"    rep(q,Q) mo.query(l,r);//順番にクエリ入力",
			"",
			"    V<ll> cnt(N);",
			"    V<ll> Ans(Q);",
			"    ll ans = 0;",
			"    auto add = [&](auto i){",
			"        ans -= cnt[A[i]]/2;",
			"        cnt[A[i]]++;",
			"        ans += cnt[A[i]]/2;",
			"    };",
			"    auto erase = [&](auto i){",
			"        ans -= cnt[A[i]]/2;",
			"        cnt[A[i]]--;",
			"        ans += cnt[A[i]]/2;",
			"    };",
			"    auto out = [&](auto q){",
			"        Ans[q] = ans;",
			"    };",
			"    mo.solve(add, erase, out);",
			"    mo.solve(add_left, add_right, erase_left, erase_right, out);",
			"    ABC242G",
			"*/",
		],
		"description": "Mo's Algorithm",
	},

	"Others/MyHash": {
		"scope": "cpp",
		"prefix": "hash",
		"body": [
			"#include \"others/my_hash.hpp\"",
			"/*",
			"    MyHashGenerator<ll> gen(3*N);",
			"    MyHash h = gen.get(a);",
			"    h = h ^ gen.hash(b);",
			"    if(h==gen.hash(a)){}",
			"    c++hash, mtrnd(), a*(a+1346)*(a*9185)%998244353",
			"*/",
		],
		"description": "my hash ",
	},

	"pair extention": {
		"scope": "cpp",
		"prefix": "pair extention",
		"body": [
			"//pair同士",
			"template<typename T, typename U> pair<T,U> operator+(const pair<T,U>& a, const pair<T,U>& b){return pair<T,U>(a.first+b.first, a.second+b.second);}",
			"template<typename T, typename U> pair<T,U> operator-(const pair<T,U>& a, const pair<T,U>& b){return pair<T,U>(a.first-b.first, a.second-b.second);}",
			"template<typename T, typename U> T inner_prod(const pair<T,U>& a, const pair<T,U>& b){return a.first*b.first + a.second*b.second;}",
			"template<typename T, typename U> T outer_prod(const pair<T,U>& a, const pair<T,U>& b){return a.first*b.second - a.second*b.first;}",
			"//スカラー",
			"template<typename S, typename T, typename U> pair<T,U> operator+(const S s, const pair<T,U>& p){return pair<T,U>(s+p.first, s+p.second);}",
			"template<typename S, typename T, typename U> pair<T,U> operator+(const pair<T,U>& p, const S s){return pair<T,U>(p.first+s, s+p.second+s);}",
			"template<typename S, typename T, typename U> pair<T,U> operator-(const S s, const pair<T,U>& p){return pair<T,U>(s-p.first, s-p.second);}",
			"template<typename S, typename T, typename U> pair<T,U> operator-(const pair<T,U>& p, const S s){return pair<T,U>(p.first-s, p.second-s);}",
			"template<typename S, typename T, typename U> pair<T,U> operator*(const S s, const pair<T,U>& p){return pair<T,U>(s*p.first, s*p.second);}",
			"template<typename S, typename T, typename U> pair<T,U> operator*(const pair<T,U>& p, const S s){return pair<T,U>(p.first*s, p.second*s);}",
			"template<typename S, typename T, typename U> pair<T,U> operator/(const pair<T,U>& p, const S s){return pair<T,U>(p.first/s, p.second/s);}",
			"//互いに素にする.int, llのみ",
			"template<typename T> pair<T, T> coprime(pair<T, T> p, bool distinct_opposite = false){",
			"    if(p.fi==0&&p.se==0) return p;",
			"    else if(p.fi==0){p.se = (distinct_opposite?p.se/abs(p.se):1);}",
			"    else if(p.se==0){p.fi = (distinct_opposite?p.fi/abs(p.fi):1);}",
			"    else{//firstを正になるように",
			"        T g = (distinct_opposite?gcd(p.fi, p.se):gcd(p.fi, p.se)*(p.fi/abs(p.fi)));",
			"        p.fi/=g; p.se/=g;",
			"    }",
			"    return p;",
			"}",
			"//ノルム",
			"template<typename T> T norm(const pair<T,T>& p){return sqrt(p.fi*p.fi+p.se*p.se);}",
			"template<typename T> T norm2(const pair<T,T>& p){return p.fi*p.fi+p.se*p.se;}",
			"//回転rad",
			"template<typename T> pair<T,T> rotate(pair<T,T> p, double angle){return {p.fi*cos(angle)-p.se*sin(angle), p.fi*sin(angle)+p.se*cos(angle)};}",
			"",
		],
		"description": "pair extention",
	},

	"power": {
		"scope": "cpp",
		"prefix": "power",
		"body": [
			"template<typename T = long long int >",
			"T POW(long long a, long long b, long long mod = 0){",
			"   T ret = 1;",
			"   T tmp = a;",
			"   if(mod) tmp%=mod;",
			"   while(b){",
			"     if(b&1){",
			"       ret *= tmp;",
			"       if(mod) ret%=mod;",
			"     }",
			"     b /= 2;",
			"     if(b) tmp *= tmp;",
			"     if(mod) tmp%=mod;",
			"   }",
			"   return ret;",
			"}",
			"// ll result = POW(5,3); ->125",
			"// POW<boost::mp::int128_t>(a,x,mod);"
		],
		"description": "整数power",
	},

	"rand": {
		"scope": "cpp",
		"prefix": "rand",
		"body": [
			"struct Random{",
			"    const unsigned SEED;",
			"    mt19937 engine;",
			"    unsigned long long mod=0;",
			"",
			"    Random(): SEED(random_device()()), engine(SEED) {}",
			"    Random(unsigned long long mod_): SEED(random_device()()), engine(SEED), mod(mod_) {}",
			"    unsigned operator()(){return (mod? engine()%mod: engine());}",
			"//    Random rand;",
			"//    cout<<rand()<<endl;",
			"//    Random mrand(MOD); //->mod rand",
			"//    cout<<mrand()<<endl;",
			"};",

		],
		"description": "random number",
	},

	"rand(正規分布)": {
		"scope": "cpp",
		"prefix": "rand",
		"body": [
			"struct NormalDistRandom{",
			"    const unsigned SEED;",
			"    mt19937 engine;",
			"    // default_random_engine engine;",
			"",
			"    double mean = 0.;",
			"    double stddev = 1.;",
			"    normal_distribution<> dist;",
			"",
			"    NormalDistRandom(double mean, double stddev):SEED(random_device()()), engine(SEED)",
			"    , mean(mean), stddev(stddev), dist(normal_distribution<>(mean, stddev)) {}",
			"    double operator()(){",
			"        return dist(engine);",
			"    }",
			"    /*",
			"    正規分布 : 平均，　標準偏差",
			"    NormalDistRandom ndrand(0.0, 1.0);",
			"    cout<< ndrand() <<endl;",
			"",
			"    */",
			"};"
		],
		"description": "normal distribution random number 正規分布",
	},

	"sort": {
		"scope": "cpp",
		"prefix": "sort",
		"body": [
			"   sort(ALL(), [&](auto& a, auto& b){",
			"      return a<b;",
			"   });"
		],
		"description": "ラムダ式ソートテンプレ",
	},

	"Sort/bubble_sort": {
		"scope": "cpp",
		"prefix": "bubble sort",
		"body": [
			"#include \"sort/bubble_sort.hpp\"",
		],
		"description": "バブルソート．O(N^2)．転倒数返す",
	},

	"Sort/merge_sort": {
		"scope": "cpp",
		"prefix": "merge sort",
		"body": [
			"#include \"sort/merge_sort.hpp\"",
		],
		"description": "マージソート．O(NlogN)．転倒数返す",
	},

	"sqrtll": {
		"scope": "cpp",
		"prefix": "sqrtll",
		"body": [
			"ll sqrtll(ll a){",
			"    ll s = ll(sqrt(a));",
			"    while(s*s<a) s++;",
			"    while(s*s>a) s--;",
			"    return s;",
			"    /*",
			"        s*s<=aとなるsを返す",
			"        a=3 -> s=1",
			"        a=4 -> s=2",
			"        a=5 -> s=2",
			"        lower_bound",
			"    */",
			"}",
		],
		"description": "sqrtll",
	},

	"string io": {
		"scope": "cpp",
		"prefix": "string split io file read",
		"body": [
			"vector<string> readfile(string filename){ ",
			"    vector<string> ret;",
			"    ifstream ifs(filename); ",
			"    string line; ",
			"    while(getline(ifs,line)){ ",
			"        ret.push_back(line); ",
			"    } ",
			"    return ret; ",
			"}",
			"",
			"string readline(){ ",
			"    string ret; ",
			"    getline(cin, ret); ",
			"    return ret;",
			"}",
			"",
			"vector<string> split(const string& s_in, string split=\",\"){ ",
			"    vector<string> ret; ",
			"    string tmp; ",
			"    for(int i=0;i<(int)s_in.size();i++){",
			"        bool found = false; ",
			"        for(int j=0;j<(int)split.size();j++){ ",
			"            if(s_in[i]==split[j]){ ",
			"                if(tmp!=\"\"){ret.push_back(tmp);} ",
			"                tmp = \"\"; ",
			"                found = true; ",
			"                break; ",
			"            }",
			"        } ",
			"        if(!found) tmp+=s_in[i];",
			"    } ",
			"    if(tmp!=\"\") ret.push_back(tmp); ",
			"    return ret;",
			"}",
			"",
			"vector<long long> int_split(const string& s_in, string split=\",\"){ ",
			"    vector<long long> ret; ",
			"    string tmp; ",
			"    for(int i=0;i<(int)s_in.size();i++){",
			"        bool found = false; ",
			"        for(int j=0;j<(int)split.size();j++){ ",
			"            if(s_in[i]==split[j]){",
			"                if(tmp!=\"\"){",
			"                    ret.push_back(stoll(tmp));",
			"                }",
			"                tmp = \"\"; ",
			"                found = true; ",
			"                break; ",
			"            }",
			"        }",
			"        if(!found) tmp+=s_in[i];",
			"    } ",
			"    if(tmp!=\"\") ret.push_back(stoll(tmp));",
			"    return ret;",
			"}",
			"",
			"vector<double> double_split(const string& s_in, string split=\",\"){ ",
			"    vector<double> ret;",
			"    string tmp; ",
			"    for(int i=0;i<(int)s_in.size();i++){",
			"        bool found = false;",
			"        for(int j=0;j<(int)split.size();j++){ ",
			"            if(s_in[i]==split[j]){ ",
			"                if(tmp!=\"\"){",
			"                    ret.push_back(stod(tmp));",
			"                }",
			"                tmp = \"\"; ",
			"                found = true; ",
			"                break; ",
			"            }",
			"        } ",
			"        if(!found) tmp+=s_in[i];",
			"    }",
			"    if(tmp!=\"\") ret.push_back(stod(tmp)); ",
			"    return ret;",
			"}",
			"",
			"void save(string filename, const vector<string>& data){",
			"    ofstream ofs(filename);",
			"    for(const auto& line:data){",
			"        ofs<<line<<endl;",
			"    }",
			"    ofs.close();",
			"}",
			"//vector<string> file = readfile(\"text.csv\");",
			"//string line = readline();",
			"//vector<string> sp = split(\"a,b,av. d,tf\", \",.\");",
			"//vector<long long> isp = int_split(\"95945435, 1000000007,   4566.6\", \",\");",
			"//vector<double> dsp = double_split(\"999.4, 3 33,5, 111.3\", \", \");",
			"//for(auto s: dsp) cout<<s<<endl;",

		],
		"description": "string io",
	},

	"String/dynamic_rolling_hash": {
		"scope": "cpp",
		"prefix": "dynamic rolling hash",
		"body": [
			"#include \"string/dynamic_rolling_hash.hpp\"",
			"/*",
			"DynamicRollingHash<mint> drh(11);//基底",
			"drh.push_back('a');",
			"drh.push_front(1);",
			"drh.pop_back(99);",
			"drh.pop_front(10);",
			"drh[0];",
			"drh.set(i,7);",
			"rdh.hash, rdh.val();",
			"if(rd1==rdh2){",
			"}",
			"hash = A[0]*b^3 + A[1]*b^2 + A[2]*b^1 + A[3];",
			"*/",
		],
		"description": "可変長ロリハ．先頭と末尾を変更可能．deque",
	},

	"String/editable_rolling_hash": {
		"scope": "cpp",
		"prefix": "editable rolling hash",
		"body": [
			"#include \"string/editable_rolling_hash.hpp\"",
			"/*",
			"    //modint型を渡す想定．中身はセグ木．",
			"    EditableRollingHash<mint> rh(S.size(), 11);",
			"    rep(i,N) rh.set(i,S[i]);",
			"    rh.get(i);",
			"    rh.prod(l,r);",
			"*/"
		],
		"description": "固定長ロリハ．途中1文字変更が可能なロリハ.セグ木",
	},

	"String/rolling_hash": {
		"scope": "cpp",
		"prefix": "rolling hash",
		"body": [
			"#include \"string/rolling_hash.hpp\"",
			"/*",
			"Luzhild",
			"RollingHash rh(b);",
			"string s = \"abc\";",
			"hTable = rh.build(s);",
			"h = rh.query(hTable,l,r);//[l,r)のハッシュ",
			"h = rh.combine(h1,h2,h2len);//h1,h2を結合",
			"len = rh.lcp(hTable1,l1,r1,hTable2,l2,r2);//2区間の最長共通接頭辞",
			"*/"
		],
		"description": "固定長ロリハ．テーブル式",
	},

	"String/treap_rolling_hash": {
		"scope": "cpp",
		"prefix": "treap rolling hash",
		"body": [
			"#include \"string/treap_rolling_hash.hpp\"",
			"/*",
			"    TreapRollingHash<mint> rh(11);//b",
			"    rep(i,S.size()){rh.insert(i,S[i]);}",
			"    rh.size();",
			"    rh.query(l,r);",
			"    rh.dump();",
			"    rh.erase();",
			"*/"
		],
		"description": "implicit treapを使ったロリハ．任意位置に挿入削除可能",
	},

	
	"Structure/others/cummulative_sum_2d": {
		"scope": "cpp",
		"prefix": "cumulative sum 2D",
		"body": [
			"#include \"structure/others/cumulative_sum_2d.hpp\"",
			"/*",
			"	CumulativeSum2D<ll> sum2d(H, W);",
			"	rep(h,H) rep(w,W) sum2d.set(h, w, A[h][w]);",
			"	sum2d.build();",
			"	sum2d._get(H,W);",
			"	cout<< sum2d.get(h, w, H, W) << endl;",
			"	//はみ出した分はトーラスとして計算．",
			"*/",
		],
		"description": "2次元累積和（トーラス対応）",
	},

	"Structure/others/range_kth_query": {
		"scope": "cpp",
		"prefix": "range kth query",
		"body": [
			"#include \"structure/others/range_kth_query.hpp\"",
			"/*",
			"   RKQ<ll> rkq;",
			"   rkq.build(A);//Nlog(N)",
			"   PL(rkq.findKth(L,R,K))//[L,R),K. 全部0-index. log(LINF)*sqrt(N)",
			"   PL(rkq.findKth2(L,R,K))// log(N)*sqrt(N)",
			"   h ttps://judge.yosupo.jp/submission/161834"
			"*/",
		],
		"description": "range kth query. ",
	},

	"Structure/others/sparse_table": {
		"scope": "cpp",
		"prefix": "sparse table",
		"body": [
			"#include \"structure/others/sparse_table.hpp\"",
			"/*",
			"int op(const int& a, const int& b){",
			"    return max(a,b);",
			"}",
			"",
			"    int N = 10;",
			"    vector<int> A(N);",
			"    for(int i=0;i<N;i++) A[i] = i;",
			"    SparseTable st(A, &op);",
			"    //auto st = get_sparse_table(A, &op);",
			"    int l = 3, r = 7;",
			"    EL(st.fold(l,r))",
			"*/"
		],
		"description": "スパーステーブル",
	},

	"Structure/pbds/hash_map": {
		"scope": "cpp",
		"prefix": "pbds hashmap",
		"body": [
			"#include <functional>",
			"#include <cassert>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/hash_policy.hpp>",
			"using namespace __gnu_pbds;",
			"",
			"struct int_hash : public unary_function<int, size_t>",
			"{",
			"  inline size_t",
			"  operator()(const int& r_i) const",
			"  { return r_i; }",
			"};",
			"",
			"template<typename T, typename U>",
			"using HashMap = gp_hash_table<",
			"    T,",
			"    U,",
			"    std::hash<T>, //MyHashFUnction",
			"    equal_to<T>,",
			"    // Combining function.",
			"    direct_mask_range_hashing<>,",
			"    // Probe function.",
			"    linear_probe_fn<>,",
			"    // Resize policy.",
			"    hash_standard_resize_policy<",
			"    hash_exponential_size_policy<>,",
			"    hash_load_check_resize_trigger<>,",
			"    /* Allow external access to size.",
			"     * Without setting this to true, external resizing",
			"     * is not possible.",
			"     */",
			"    true> >;",
			"",
			"/*",
			"    ll N; cin>>N;",
			"    HashMap<ll,ll> mp;",
			"    mp.resize(N*3);",
			"    rep(i,N) mp[i] = i;",
			"    auto it = mp.find(3);",
			"    if(it==mp.end()) PL(-1)",
			"*/"
		],
		"description": "pbds hashmap.unordered_mapより速いらしい？",
	},

	"Structure/pbds/multiset": {
		"scope": "cpp",
		"prefix": "pbds multiset",
		"body": [
			"#include \"structure/pbds/pbds_multiset.hpp\"",
			"/*",
			"    // PBDSMultiset<ll, greater<pair<ll,int>>> st;",
			"    PBDSMultiset<ll> st;",
			"    rep(i,10) st.insert(i);",
			"    int id = st.lower_bound(4);",
			"    int id = st.upper_bound(4);",
			"    int id = st.find(4);",
			"    EL(id)",
			"    EL(st[id])",
			"    repi(i,2,5) st.erase(i);",
			"    rep(i,st.size()) PL(st[i])",
			"    abc094c",
			"*/"
		],
		"description": "pbds multiset",
	},

	"Structure/pbds/set": {
		"scope": "cpp",
		"prefix": "pbds set",
		"body": [
			"#include \"structure/pbds/pbds_set.hpp\"",
			"/*",
			"    //PBDSSet<ll, greater<ll>> st;",
			"    PBDSSet<ll> st;",
			"    rep(i,10) st.insert(i);",
			"    st.erase(5);",
			"    rep(i,st.size()) EL(st[i])",
			"    EL(st.lower_bound(7))",
			"    EL(st.find(-1))",
			"*/"
		],
		"description": "pbds set",
	},

	"Structure/pbds/tree": {
		"scope": "cpp",
		"prefix": "pbds tree",
		"body": [
			"#include<ext/pb_ds/assoc_container.hpp>",
			"#include<ext/pb_ds/tree_policy.hpp>",
			"#include<ext/pb_ds/tag_and_trait.hpp>",
			"using namespace __gnu_pbds;",
			"// using namespace pb_ds;",
			"template<typename T>",
			"using rbtree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"template<typename T>",
			"using splaytree = tree<T, null_type, less<T>, splay_tree_tag, tree_order_statistics_node_update>;",
			"/*",
			"    rbtree<ll> tree;",
			"    ll N = 10;",
			"    rep(i,N) tree.insert(i);",
			"    auto it = tree.find_by_order(3);",
			"    EL(tree.order_of_key(3))",
			"*/",
		],
		"description": "pbds tree.i番目が検索可能なstd::set",
	},

	"Structure/queue/middle_queue": {
		"scope": "cpp",
		"prefix": "middle queue",
		"body": [
			"#include \"structure/queue/middle_queue.hpp\"",
			"//MiddleQueue<ll> que(-LINF, LINF)",
			"//que.push(a);//Nが偶数の時，小さいほう",
			"//que.push2(a);//Nが偶数の時，中間値．pop非対応",
			"//que.pop();",
			"//pair<ll,ll> p = que.top();",
			"//ABC127F"
		],
		"description": "middle queue. median 中央値出力",
	},

	"Structure/segtree/longest_continuous_bits": {
		"scope": "cpp",
		"prefix": "longest continuuous bits lazy segtree",
		"body": [
			"#include \"structure/segtree/longest_continuous_bits.hpp\"",
			"/*",
			"ll N,Q; cin>>N>>Q;",
			"V<ll> A(N); cin>>A;",
			"LongContinuousBits::LazyRMQ<ll> seg(N);",
			"seg.set(i, LongContinuousBits::GetS0<ll>());",
			"seg.set(i, LongContinuousBits::GetS1<ll>());",
			"",
			"// 0,1をそれぞれ何に変換するか",
			"seg.apply(L,R,{1, 0});//xor",
			"seg.apply(L,R,{0, 0});//all 0",
			"seg.apply(L,R,{1, 1});//all 1",
			"",
			"cout<<seg.prod(L,R).long1<<endl;",
			"num0, num1, long0",
			"",
			"abc322f"
			"abc341e"
			"*/",
		],
		"description": "",
	},

	"Structure/set/top_k_sum_multiset": {
		"scope": "cpp",
		"prefix": "top K sum multiset",
		"body": [
			"#include \"structure/set/top_k_sum_multiset.hpp\"",
			"/*",
			"TopKSumMultiSet<ll> Kst(K);//小さい方K",
			"TopKSumMultiSet<ll,greater<ll>> Kst(K);//大きいほうK",
			"Kst.insert(a);",
			"Kst.erase(a);",
			"EL(Kst.sumL);",
			"EL(Kst.size());",
			"EL(Kst.clear());",
			"//ABC281E, ABC306E",
			"*/"
		],
		"description": "昇順（降順）K項の和",
	},

	"Structure/tree/implicit_treap": {
		"scope": "cpp",
		"prefix": "implicit treap",
		"body": [
			"#include \"structure/tree/implicit_treap.hpp\"",
			"/*",
			"SumAffineQuery<ll> tree;",
			"MinmaxAffineQuery<Pll,Pll> tree;",
			"tree.set_by_vector(A);",
			"tree.insert(pos, {x,x}));//",
			"tree.update(l,r,{a,b});//ax+b",
			"int sz = tree.size();",
			"tree.erase(pos);",
			"tree.reverse(l,r);",
			"tree.rotate(l,m,r);//[l, r)の先頭がmになるようにシフトさせる。std::rotateと同じ仕様",
			"auto x = tree.query(l,r);",
			"auto x = tree[0];",
			"tree.binary_search(l,r,x);",
			"//tree.dump();//全出力",
			"// 二分探索。[l, r)内のkでf0(tr[k], x) != xとなる最左/最右のもの。存在しない場合は-1",
			"// // たとえばMinMonoidの場合、x未満の最左/最右の要素の位置を返す",
			"*/",
		],
		"description": "任意の位置に挿入・削除，区間回転・反転，区間加算，区間SUm,Min等が可能",
	},

	"Structure/tree/ordered_map": {
		"scope": "cpp",
		"prefix": "ordered map",
		"body": [
			"#include \"structure/tree/ordered_map.hpp\"",
			"/*",
			"    std::mapと同じ．max(),min()が定義されてなかったら動かないかも．",
			"    stringは対策済み．",
			"    ordered_map<string,ll,true> mp;",
			"    ordered_map<ll,ll,true> mp(-LINF);//デフォルト値",
			"    mp[k] = val;",
			"    rep(i,mp.size()){",
			"        PS(mp.key(i)) PL(mp.val(i))",
			"    }",
			"    mp.dump();",
			"    mp[S]++;",
			"*/"
		],
		"description": "ordered map by implicit treap",
	},

	"Structure/tree/ordered_multiset": {
		"scope": "cpp",
		"prefix": "ordered multiset",
		"body": [
			"#include \"structure/tree/ordered_multiset.hpp\"",
			"/*",
			"//std::multisetと同じ．降順にしたければ第二テンプレート引数false;",
			"降順の時，findおよびlower_boundは見つかれば末尾を指す．",
			"ちゃんと先頭側がほしいなら，lower_bound(a+1)+1すれば求まりはする．",
			"ordered_multiset<ll,true> st;",
			"st.insert(a);",
			"st.erase(a);",
			"int pos = st.lower_bound(a);//なければsize()を返す",
			"int pos = st.find(a);//なければsize()を返す",
			"st.erase_at(pos);",
			"int sz = st.size();",
			"tree[pos];//右辺値アクセスは可能",
			"abc094c",
			"*/"
		],
		"description": "ordered multiset by implicit treap",
	},

	"Structure/tree/ordered_set": {
		"scope": "cpp",
		"prefix": "ordered set",
		"body": [
			"#include \"structure/tree/ordered_set.hpp\"",
			"/*",
			"//std::setと同じ．降順にしたければ第二テンプレート引数false;",
			"ordered_set<ll,true> st;",
			"st.insert(a);",
			"st.erase(a);",
			"int pos = st.lower_bound(a);//なければsize()を返す",
			"int pos = st.find(a);//なければsize()を返す",
			"st.erase_at(pos);",
			"int sz = st.size();",
			"tree[pos];//右辺値アクセスは可能",
			"*/"
		],
		"description": "ordered set by implicit treap",
	},

	"Structure/tree/pair_query": {
		"scope": "cpp",
		"prefix": "pair query",
		"body": [
			"#include \"pair_query.hpp\"",
			"/*",
			"    要素が重複しててもok",
			"    PairQuery<ll,ll,true> pq;//true==昇順",
			"    pq.add({l,r});",
			"    ll sum = pq.query(x);//xおよびxより左にある項のsecond和",
			"    ll sum = pq.sum(r);//[0,r)のsecond和",
			"    pq[id];",
			"    pq.dump();",
			"    pq.erase(id);",
			"    pq.erase_at(Pxy);",
			"",
			"*/"
		],
		"description": "firstがx以下の項のsecondの和を計算",
	},

	"Structure/tree/priority_sum": {
		"scope": "cpp",
		"prefix": "priority sum",
		"body": [
			"#include \"structure/tree/priority_sum.hpp\"",
			"/*",
			"PrioritySum<ll,true> ps;//昇順",
			"rep(i,N) ps.add(A[i]);",
			"ps.erase_at(1);",
			"ps.erase_value(A[0]);",
			"ps.erase_all(a);//値がaの要素を全削除",
			"ll sum = ps.sum(3);//先頭k個の総和",
			"ll sum = ps.sum(l,r);//[l,r)の総和",
			"int ps.lower_bound(a);//昇順，降順に注意",
			"upper_boundあるけど，++が定義されてないものは非対応なので，コメントアウト済",
			"// ABC306E",
			"*/"
		],
		"description": "任意の上位K個の和が可能．削除もできる",
	},

	"Structure/trie/trie": {
		"scope": "cpp",
		"prefix": "trie",
		"body": [
			"#include \"structure/trie/trie.hpp\"",
			"/*",
			"    Trie<26, 'a'> tr;",
			"    id[i] = tr.insert(S[i]);//追加．第二引数に文字列のidを指定もできる（S[i]のi）",
			"    //引数:文字列，文字列の何文字目からか，ノードの開始点，文字列の番号",
			"    id = tr.lcp_id(s[i], s[j]);//共通接頭辞の末尾id",
			"    len = tr.lcp_len(s[i], s[j]);//共通接頭辞の長さ",
			"    t = tr.lcp_string(s[i], s[j]);//共通接頭辞返す",
			"    t = tr.create_string(id);//idまでの文字列返す",
			"    id = tr.find(S[i]);//構築せず，既存で進めるだけ進む．depthと文字列の長さが等しければ，構築済み．",
			"    id = tr.Kth_element(k);//insertされた要素のうち，辞書順k番目の要素の末尾id.0-indexed",
			"    k = tr.is_Kth(s[i]);//もしinsertされたら辞書順何番目か？",
			"    int shared = tr[id].shared;//いくつの文字列がその頂点通ったか．その頂点で終わっていたら加算されていない．",
			"    vector<int>& accept = tr[id].accept;//その頂点で終わった文字列のid．",
			"    //insert以外は加算しない．",
			"    //findは構築もしない",
			"    //その他は構築だけする．",
			"",
			"    //中身を辿るとき",
			"    p = tr.proceed(str);",
			"    while(p!=0){",
			"        p = tr[p].parent;",
			"        //val, parent, children[char_size], depth, shared, vector::accept",
			"        children[c]は存在しなければ-1,そうでなければid",
			"    }",
			"    AGC047B",
			"*/",
		],
		"description": "trie木.内部はvector<Node>",
	},

	"Structure/union_find/union_find": {
		"scope": "cpp",
		"prefix": "union find",
		"body": [
			"#include \"structure/union_find/union_find.hpp\"",
			"/*",
			"UnionFind uf(N);",
			"UnionFindUM<ll> uf(N);//unordered_map",
			"auto MergeF = [&](int p, int c)->bool {return uf.sz[p]>=uf.sz[c];}",
			"auto UpdateF = [&](int p, int c)->void {W[p]+=W[c];}",
			"uf.merge(x, y, w=0);",
			"uf.mergeM(x, y, MergeF, w=0);",
			"uf.mergeU(x, y, UpdateF, w=0);",
			"uf.mergeMU(x, y, MergeF, UpdateF, w=0);",
			"size(x)",
			"group(x)",
			"Add(x)",
			"*/"
		],
		"description": "union find",
	},

	"Structure/union_find/unordered_map_union_find": {
		"scope": "cpp",
		"prefix": "unordered map union find",
		"body": [
			"#include \"structure/union_find/unordered_map_union_find.hpp\"",
			"/*",
			"UnorderedMapUnionFind<int> uf(N*3);//reserve数",
			"string等も可．hash関数が定義されてれば，なんでも．",
			"if(!uf.same(x,y))uf.merge(x,y);",
			"EL(uf.size())//全体",
			"EL(uf.size(x))//xの属するサイズ",
			"EL(uf.leader(x))//xのリーダー．新規，単体は自身を返す",
			"for(auto x:uf.st)//含まれてる頂点走査",
			"ABC277C",
			"*/"
		],
		"description": "離散 union find",
	},

	"Structure/union_find/unordered_map_update_union_find": {
		"scope": "cpp",
		"prefix": "unordered map weight update union find",
		"body": [
			"#include \"structure/union_find/unordered_map_update_union_find.hpp\"",
			"/*",
			"頂点型，重み型",
			"UnorderedMapUpdateUnionFind<int, int> uf(N*3);//reserve数",
			"auto cmp = [&](int parent, int child)->bool {return uf.sz[parent]>=uf.sz[child];};//マージする際にあるべき状態",
			"auto f = [&](int parent, int child)->void {uf.weight[parent] += uf.weight[child];};//重みに対して行う処理",
			"if(!uf.same(x,y))uf.merge(x,y,cmp,f);",
			"EL(uf.size())//全体",
			"EL(uf.size(x))//xの属するサイズ",
			"EL(uf.leader(x))//xのリーダー．新規，単体は-1を返す",
			"for(auto x:uf.st)//含まれてる頂点走査",
			"uf[x] = 1;//リーダーにアクセスされる．",
			"ABC277C",
			"*/"
		],
		"description": "unordered map update union find",
	},

	"Structure/union_find/unordered_map_weighted_union_find": {
		"scope": "cpp",
		"prefix": "unordered map weighted union find",
		"body": [
			"#include \"structure/union_find/unordered_weighted_union_find.hpp\"",
			"/*",
			"UnorderedMapWeightedUnionFind<ll,ll> tree(N);//頂点，重み型",
			"if(!tree.same(x,y)) tree.merge(x,y,w);// weight[y] = weight[x]+w;",
			"tree.leader();",
			"tree.diff(x,y);//weight(y)-weight(x);",
			"abc280 F",
			"abc087 D",
			"*/"
		],
		"description": "離散ポテンシャルunion find",
	},

	"Structure/union_find/weighted_union_find": {
		"scope": "cpp",
		"prefix": "weighted union find",
		"body": [
			"#include \"structure/union_find/weighted_union_find.hpp\"",
			"/*",
			"WeightedUnionFind<ll> tree(N);",
			"if(!tree.same(x,y)) tree.merge(x,y,w);// weight[y] = weight[x]+w;",
			"tree.leader();",
			"tree.diff(x,y);//weight(y)-weight(x);",
			"abc280 F",
			"*/"
		],
		"description": "weighted union find",
	},

	"Structure/union_find/update_union_find": {
		"scope": "cpp",
		"prefix": "update union find",
		"body": [
			"#include \"structure/union_find/update_union_find.hpp\"",
			"/*",
			"UpdateUnionFind uf(N);",
			"V<ll> Weight(N);",
			"rep(i,N) W[i] = A[i];",
			"auto cmp = [&](int parent, int child)->bool {return uf.sz[parent]>=uf.sz[child];};//マージする際にあるべき状態",
			"auto f = [&](int parent, int child)->void {Weight[parent] += Weight[child];};//重みに対して行う処理",
			"if(!uf.same(x,y)) uf.merge(x, y, cmp, f);",
			"uf.leader(i); == uf[i];",
			"abc277D2",
			"abc295G",
			"abc239F",
			"agc002c",
			"*/"
		],
		"description": "update union find",
	},

	"Structure/vector/biased_vector": {
		"scope": "cpp",
		"prefix": "biased vector",
		"body": [
			"#include \"structure/vector/biased_vector.hpp\"",
			"template<typename T> using BV = biased_vector<T>;",
			"/*",
			"BV<ll> vec;//vectorと同じコンストラクタ",
			"vec.setB(-5);//先頭のインデックスを決定",
			"B[-5] = 3;",
			"EL(B)//->vectorの<<が呼ばれる",
			"for(auto),B.begin()なども，内部vector基準",
			"*/",
		],
		"description": "任意のn-indexedなvectorが可能",
	},

	"Structure/wavelet_matrix/wavelet_matrix": {
		"scope": "cpp",
		"prefix": "wavelet matrix",
		"body": [
			"#include \"structure/wavelet_matrix/wavelet_matrix.hpp\"",
			"/*",
			"   V<ll> A(N);",
			"   CompressedWaveletMatrix< ll, 31 > mat(A);",
			"   mat.get(a);//昇順index",
			"   mat.access(k);//全体昇順k番目",
			"   mat[k];//上に同じ",
			"   mat.kth_smallest(l, r, k);//区間内昇順k番目",
			"   mat.kth_largest(l, r, k);",
			"   mat.range_freq(l,r,upper);//[l,r)の種類数",
			"   mat.range_freq(l,r,lower,upper);",
			"   mat.prev_value(l,r,val);",
			"   mat.next_value(l,r,val);",
			"   from luzhild.",
			"   arc165b"
			"*/",
		],
		"description": "wavelet matrix",
	},

	"timer": {
		"scope": "cpp",
		"prefix": "timer",
		"body": [
			"#include \"utils/timer.hpp\"",
			"//Timer timer;",
			"//if(timer.pass()) PL(timer.time())",
			"//TIMER_LOG(timer, \"comment\")",
			"//timer.print();",
		],
		"description": "timer.主にAHC用",
	},

	"python%": {
		"scope": "cpp",
		"prefix": "amari %",
		"body": [
			"template<typename T, typename F>",
			"T amari(T a, F b){",
			"   return (a%b+b)%b;",
			"}",
		],
		"description": "% like python",
	},

	"階乗": {
		"scope": "cpp",
		"prefix": "kaijo",
		"body": [
			"mint kaijo(ll n){",
			"    mint ret = 1;",
			"    for(int i=1;i<=n;i++) ret *= i;",
			"    return ret;",
			"}",
		],
		"description": "階乗",
	},

	"行列計算": {
		"scope": "cpp",
		"prefix": "gyouretukeisann MATRIX",
		"body": [
			"template<typename T> ",
			"vector<vector<double>> convert_double(vector<vector<T>>& A){",
			"    vector<vector<double>> ret(A.size(), vector<double>(A[0].size()));",
			"    for(int i=0;i<A.size();i++)",
			"        for(int j=0;j<A.size();j++)",
			"            ret[i][j] = A[i][j];",
			"    return ret;",
			"}",
			"",
			"template<typename T> ",
			"vector<vector<int>> convert_int(vector<vector<T>>& A){",
			"    vector<vector<int>> ret(A.size(), vector<double>(A[0].size()));",
			"    for(int i=0;i<A.size();i++)",
			"        for(int j=0;j<A.size();j++)",
			"            ret[i][j] = A[i][j]+0.1;",
			"    return ret;",
			"}",
			"",
			"",
			"template <typename T>",
			"vector<vector<T>> transpose(vector<vector<T>>& A){",
			"    vector<vector<T>> B(A[0].size(), vector<T>(A.size()));",
			"    for(int i=0;i<A.size();i++)",
			"        for(int j=0;j<A[0].size();j++)",
			"            B[j][i] = A[i][j];",
			"    return B;",
			"}",
			"",
			"template <typename T>",
			"vector<vector<T>> prod(const vector<vector<T>>& A, const vector<vector<T>>& B){",
			"    vector<vector<T>> C(A.size(), vector<T>(B[0].size()));",
			"    for(int i=0;i<A.size();i++)",
			"        for(int j=0;j<B[0].size();j++)",
			"            for(int k=0;k<A[0].size();k++)",
			"                C[i][j] += A[i][k] * B[k][j];",
			"    return C;",
			"}",
			"",
			"template <typename T>",
			"vector<T> prod(vector<vector<T>>& A, vector<T>& B){",
			"    vector<T> C(A.size());",
			"    for(int i=0;i<A.size();i++)",
			"        for(int j=0;j<B.size();j++)",
			"                C[i] += A[i][j] * B[j];",
			"    return C;",
			"}",
			"",
			"template <typename T>",
			"vector<vector<T>> I(int n){",
			"    vector<vector<T>> retI(n, vector<T>(n));",
			"    for(int i=0;i<n;i++) retI[i][i]=1;",
			"    return retI;",
			"}",
			"",
			"",
			"template <typename T>",
			"T det2T(vector<vector<T>>& A){",
			"    if(A.size()!=2 || A[0].size()!=2){",
			"        cerr<<\"det2 size != 2\"<<endl;",
			"        return 0;",
			"    }",
			"    T d = 0;",
			"    d += A[0][0]*A[1][1];",
			"    d -= A[0][1]*A[1][0];",
			"    return d;",
			"}",
			"",
			"template <typename T>",
			"T det3T(vector<vector<T>>& A){",
			"    if(A.size()!=3 || A[0].size()!=3){",
			"        cerr<<\"det3 size != 3\"<<endl;",
			"        return 0;",
			"    }",
			"    T d = 0;",
			"    d += A[0][0]*A[1][1]*A[2][2];",
			"    d += A[0][1]*A[1][2]*A[2][0];",
			"    d += A[0][2]*A[1][0]*A[2][1];",
			"",
			"    d -= A[0][0]*A[1][2]*A[2][1];",
			"    d -= A[0][1]*A[1][0]*A[2][2];",
			"    d -= A[0][2]*A[1][1]*A[2][0];",
			"",
			"    return d;",
			"}",
			"",
			"template <typename T>",
			"vector<vector<double>> inv2T(vector<vector<T>>& A){",
			"    T det = det2T(A);",
			"    if(det==0){",
			"        cerr<<\"inv2T: determinant==0\"<<endl;",
			"        return I<double>(2);",
			"    }",
			"    vector<vector<double>> inv = convert_double(A);",
			"",
			"    swap(inv[0][0], inv[1][1]);",
			"    inv[0][1] = -inv[0][1];",
			"    inv[1][0] = -inv[1][0];",
			"    for(int i=0;i<A.size();i++)",
			"        for(int j=0;j<A.size();j++)",
			"            inv[i][j] /= det;",
			"    return inv;",
			"}",
			"",
			"template <typename T>",
			"vector<vector<double>> inv3T(vector<vector<T>>& A){",
			"    T det = det3T(A);",
			"    if(det==0){",
			"        cerr<<\"inv2T: determinant==0\"<<endl;",
			"        return I<double>(3);",
			"    }",
			"    vector<vector<double>> inv = convert_double(A);",
			"    inv[0][0] =  A[1][1]*A[2][2] - A[1][2]*A[2][1];",
			"    inv[0][1] = -A[0][1]*A[2][2] + A[0][2]*A[2][1];",
			"    inv[0][2] =  A[0][1]*A[1][2] - A[0][2]*A[1][1];",
			"    ",
			"    inv[1][0] = -A[1][0]*A[2][2] + A[1][2]*A[2][0];",
			"    inv[1][1] =  A[0][0]*A[2][2] - A[0][2]*A[2][0];",
			"    inv[1][2] = -A[0][0]*A[1][2] + A[0][2]*A[1][0];",
			"",
			"    inv[2][0] =  A[1][0]*A[2][1] - A[1][1]*A[2][0];",
			"    inv[2][1] = -A[0][0]*A[2][1] + A[0][1]*A[2][0];",
			"    inv[2][2] =  A[0][0]*A[1][1] - A[0][1]*A[1][0];",
			"",
			"    for(int i=0;i<A.size();i++)",
			"        for(int j=0;j<A.size();j++)",
			"            inv[i][j] /= det;",
			"    return inv;",
			"}",
			"",
			"V<V<int>> A(2,V<int>(3));",
			"//rep(i,2) rep(j,3) A[i][j] = i*3+j*5;",
			"//",
			"//rep(i,A.size()) EL(A[i])",
			"//",
			"//V<V<int>> B = transpose(A);",
			"//rep(i,B.size()) EL(B[i])",
			"//",
			"//auto ans_seki = prod(A,B);",
			"//rep(i,ans_seki.size()) EL(ans_seki[i])",
			"//",
			"//V<int> vec(3,1);",
			"//vec[1] = 2; vec[2]=3;",
			"//auto MatVec = prod(A, vec);",
			"//rep(i,MatVec.size()) EL(MatVec[i])",
			"//",
			"//auto ans_seki_inv = inv2T(ans_seki);",
			"//rep(i,ans_seki_inv.size()) EL(ans_seki_inv[i]) ",
			"//auto AA = prod(convert_double(ans_seki), ans_seki_inv);",
			"//rep(i,AA.size()) EL(AA[i])",
			"//",
			"//",
			"//vector<vector<double>> A3 = {",
            "//    {1,2,3},",
            "//    {4,5,6},",
            "//    {7,8,8}",
			"//};",
			"//auto A3A3 = prod(A3, inv3T(A3));",
			"//rep(i,A3A3.size()) EL(A3A3[i])",
			"//",
			"//vector<vector<int>> test(3,vector<int>(3)); cin>>test;",
			"//auto test_result = prod(convert_double(test), inv3T(test));",
			"//test_result = inv3T(test);",
			"//rep(i,test_result.size()) EL(test_result[i])",
			""
		],
		"description": "2d, 3d matrix",
	},

	"組み合わせ": {
		"scope": "cpp",
		"prefix": "combination",
		"body": [
			"template< typename T >",
			"struct Combination {",
			"  vector< T > _fact, _rfact, _inv;",
			"",
			"  Combination(int sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {",
			"    _fact[0] = _rfact[sz] = _inv[0] = 1;",
			"    for(int i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;",
			"    _rfact[sz] /= _fact[sz];",
			"    for(int i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);",
			"    for(int i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];",
			"  }",
			"",
			"  inline T fact(int k) const { return _fact[k]; }",
			"",
			"  inline T rfact(int k) const { return _rfact[k]; }",
			"",
			"  inline T inv(int k) const { return _inv[k]; }",
			"",
			"  T P(int n, int r) const {",
			"    if(r < 0 || n < r) return 0;",
			"    return fact(n) * rfact(n - r);",
			"  }",
			"",
			"  T C(int p, int q) const {",
			"    if(q < 0 || p < q) return 0;",
			"    return fact(p) * rfact(q) * rfact(p - q);",
			"  }",
			"",
			"  T H(int n, int r) const {",
			"    if(n < 0 || r < 0) return (0);",
			"    return r == 0 ? 1 : C(n + r - 1, r);",
			"  }",
			"};",
			"//Combination<mint> Comb(MaxSize);",
			"//auto a = Comb.C(p,q);",
			"//auto b = Comb.P(n,r);",
			"//auto c = Comb.H(n,r);",
		],
		"description": "組み合わせ C,P,H",
	},

	"組み合わせ 大": {
		"scope": "cpp",
		"prefix": "combination",
		"body": [
			"mint nCr(ll n, ll r){",
			"    mint ret = 1;",
			"    repi(i,0,r){",
			"        ret *= n-i;",
			"    }",
			"    repi(i,1,r+1){",
			"        ret /= i;",
			"    }",
			"    return ret;",
			"}",
			"",
			"mint nPr(ll n, ll r){",
			"    mint ret = 1;",
			"    for(int i=0;i<r;i++) ret *= n-i;",
			"    return ret;",
			"}",
			"",
			"#define CMAX 1010",
			"int noinit = 1; ll memo[CMAX][CMAX];",
			"ll aCb(ll a, ll b) {",
			"    if (noinit) {",
			"        repi(i, 0, CMAX) repi(j, 0, CMAX) memo[i][j] = -1;",
			"        noinit = 0;",
			"    }",
			"    if (b == 0 || a == b) return 1;",
			"    if (0 <= memo[a][b]) return memo[a][b];",
			"    return memo[a][b] = aCb(a - 1, b - 1) + aCb(a - 1, b);",
			"}"

		],
		"description": "nCr (n > 10^8)",
	},

	"グラフ回転90*n": {
		"scope": "cpp",
		"prefix": "rotate90",
		"body": [
			"vector<string> rotate90n(const vector<string>& in, long long n=1){",
			"    vector<string> ret;",
			"    if(n<0)n+=4000000000000LL;",
			"    n%=4;",
			"    int h,w;",
			"    if(n%2==0) {",
			"        h = in.size();",
			"        w = in[0].size();",
			"    }",
			"    else {",
			"        h = in[0].size();",
			"        w = in.size();",
			"    }",
			"    ret = vector<string>(h,string(w,' '));",
			"    for(int i=0;i<h;i++){",
			"        for(int j=0;j<w;j++){",
			"            if(n==0) ret[i][j] = in[i][j];",
			"            if(n==1) ret[i][j] = in[w-1-j][i];",
			"            if(n==2) ret[i][j] = in[h-1-i][w-1-j];",
			"            if(n==3) ret[i][j] = in[j][h-1-i];",
			"        }",
			"    }",
			"    return ret;",
			"}",
			"//vector<string> vs(3); rep(i,3) cin>>vs[i];",
			"//###",
			"//..#",
			"//...",
			"// auto result = rotate90n(vs, 1);->",
			"//..#",
			"//..#",
			"//.##",
		],
		"description": "グラフ回転90*n",
	},

	"桁数": {
		"scope": "cpp",
		"prefix": "ketasuu",
		"body": [
			"int keta(long long a, long long b=10){",
			"   int ret = 0;",
			"   while(a){",
			"      a /= b;",
			"      ret++;",
			"   }",
			"   return ret;",
			"}",
			"//int k = keta(10057); ->5",
			"//int k = keta(8,2); ->4",
		],
		"description": "桁数",
	},

	"座標圧縮": {
		"scope": "cpp",
		"prefix": "zaatsu",
		"body": [
			"template <typename T> vector<T> CCompress(vector<T>& A){",
			"   vector<T> B = A;",
			"   sort(B.begin(), B.end());",
			"   B.erase(unique(B.begin(), B.end()), B.end());",
			"   for(int i=0;i<(int)A.size();i++){",
			"      A[i] = (int)(lower_bound(B.begin(), B.end(), A[i]) - B.begin());",
			"   }",
			"   return B;",
			"}",
			"//vector<int> A = {1,100,5,5};",
			"//auto B = CCompress(A);",
			"//-> A={0,2,1,1}, B={1,5,100}",
			"",
			"//重複を許さない座標圧縮．同じ数字は先出から割り振る",
			"template<typename T>",
			"void reorder(vector<T>& A){",
			"    vector<T> B = A;",
			"    sort(ALL(B));",
			"    for(auto& a:A){",
			"        auto it = lower_bound(B.begin(), B.end(), a);",
			"        a = it - B.begin();",
			"        (*it)--;",
			"    }",
			"}",
			"",
			"//重複を許さない座標圧縮．同じ数字は後方から割り振る",
			"template<typename T>",
			"void reorder_rev(vector<T>& A){",
			"    vector<T> B = A;",
			"    sort(ALL(B));",
			"    for(int i=A.size()-1;i>=0;i--){",
			"        auto it = lower_bound(B.begin(), B.end(), A[i]);",
			"        A[i] = it - B.begin();",
			"        (*it)--;",
			"    }",
			"}"
		],
		"description": "座標圧縮",
	},

	"しりとり": {
		"scope": "cpp",
		"prefix": "shiritori",
		"body": [
			"//const int INF = (1<<30)-1;",
			"",
			"struct Shiritori{",
			"",
			"    using P = pair<int,int>;",
			"    struct Edge{",
			"        int to, cost, id;",
			"    };",
			"",
			"    int n;",
			"    int m;",
			"    int byte;",
			"    string chars;",
			"",
			"    map<string, int> id;",
			"    vector<string> words;",
			"    vector<vector<Edge>> G;",
			"    vector<int> dist;",
			"",
			"    Shiritori(string Chars, int byte_){",
			"        chars = Chars;",
			"        byte = byte_;",
			"        n = chars.size()/byte;",
			"        for(int i=0;i<chars.size()/byte;i++) id[chars.substr(i*byte, byte)] = i;",
			"        G.resize(chars.size()/byte);",
			"    }",
			"    ",
			"    void setG(int m){",
			"        words.resize(m);",
			"        for(int i=0;i<m;i++){",
			"            cin>>words[i];",
			"            int from = id[words[i].substr(0,byte)];",
			"            int to = id[words[i].substr(words[i].size()-byte)];",
			"            int cost = 1;",
			"            G[from].push_back({to, cost, i});",
			"            //cout<<\"edge \"<<i<<\" \"<<from<<\" \"<<to<<endl;",
			"        }",
			"    }",
			"",
			"    void solve(string start){",
			"",
			"        int s = id[start];",
			"        dist.resize(n, INF);",
			"        dist[s] = 0;",
			"        ",
			"        //dijkstra",
			"        priority_queue<P,vector<P>,greater<P>> que;",
			"        que.push({0,s});",
			"",
			"        while(!que.empty()){",
			"            int d = que.top().first;",
			"            int p = que.top().second;",
			"            que.pop();",
			"            if(d>dist[p]) continue;",
			"",
			"            for(int i=0;i<G[p].size();i++){",
			"                Edge e = G[p][i];",
			"                if(dist[p]+e.cost<dist[e.to]){",
			"                    dist[e.to] = dist[p]+e.cost;",
			"                    que.push({dist[e.to], e.to});",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    int get_id(string s){",
			"        return id[s];",
			"    }",
			"};",
			"",
			"////string Chars = \"abcdefghijklmnopqrstuvwxyz\";",
			"//// string start = \"a\";",
			"//// string goal = \"z\";",
			"//// int by = 1;",
			"//",
			"//string Chars = \"あいうえお\";",
			"//string start = \"あ\";",
			"//string goal = \"お\";",
			"//int by = 3;",
			"//",
			"//Shiritori sh(Chars, by);",
			"//int m; cin>>m;",
			"//sh.setG(m);",
			"//sh.solve(start);",
			"//int g = sh.get_id(goal);",
			"//for(int i=0;i<sh.dist.size();i++) cout<<sh.dist[i]<<\" \"<<endl;",
		],
		"description": "しりとり",
	},

	"セグ木": {
		"scope": "cpp",
		"prefix": "segtree",
		"body": [
			"template< typename Monoid >",
			"struct SegmentTree {",
			"  using F = function< Monoid(Monoid, Monoid) >;",
			"",
			"  int sz;",
			"  vector< Monoid > seg;",
			"",
			"  const F f;",
			"  const Monoid M1;",
			"",
			"  SegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1) {",
			"    sz = 1;",
			"    while(sz < n) sz <<= 1;",
			"    seg.assign(2 * sz, M1);",
			"  }",
			"",
			"  void set(int k, const Monoid &x) {",
			"    seg[k + sz] = x;",
			"  }",
			"",
			"  void build() {",
			"    for(int k = sz - 1; k > 0; k--) {",
			"      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);",
			"    }",
			"  }",
			"",
			"  void update(int k, const Monoid &x) {",
			"    k += sz;",
			"    seg[k] = x;",
			"    while(k >>= 1) {",
			"      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);",
			"    }",
			"  }",
			"",
			"  Monoid query(int a, int b) {",
			"    Monoid L = M1, R = M1;",
			"    for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) {",
			"      if(a & 1) L = f(L, seg[a++]);",
			"      if(b & 1) R = f(seg[--b], R);",
			"    }",
			"    return f(L, R);",
			"  }",
			"",
			"  Monoid operator[](const int &k) const {",
			"    return seg[k + sz];",
			"  }",
			"",
			"  template< typename C >",
			"  int find_subtree(int a, const C &check, Monoid &M, bool type) {",
			"    while(a < sz) {",
			"      Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);",
			"      if(check(nxt)) a = 2 * a + type;",
			"      else M = nxt, a = 2 * a + 1 - type;",
			"    }",
			"    return a - sz;",
			"  }",
			"",
			"",
			"  template< typename C >",
			"  int find_first(int a, const C &check) {",
			"    Monoid L = M1;",
			"    if(a <= 0) {",
			"      if(check(f(L, seg[1]))) return find_subtree(1, check, L, false);",
			"      return -1;",
			"    }",
			"    int b = sz;",
			"    for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) {",
			"      if(a & 1) {",
			"        Monoid nxt = f(L, seg[a]);",
			"        if(check(nxt)) return find_subtree(a, check, L, false);",
			"        L = nxt;",
			"        ++a;",
			"      }",
			"    }",
			"    return -1;",
			"  }",
			"",
			"  template< typename C >",
			"  int find_last(int b, const C &check) {",
			"    Monoid R = M1;",
			"    if(b >= sz) {",
			"      if(check(f(seg[1], R))) return find_subtree(1, check, R, true);",
			"      return -1;",
			"    }",
			"    int a = sz;",
			"    for(b += sz; a < b; a >>= 1, b >>= 1) {",
			"      if(b & 1) {",
			"        Monoid nxt = f(seg[--b], R);",
			"        if(check(nxt)) return find_subtree(b, check, R, true);",
			"        R = nxt;",
			"      }",
			"    }",
			"    return -1;",
			"  }",
			"};",
			"  int N, Q; cin>>N>>Q;",
			"//SegmentTree< int > seg(N, [](int a, int b) { return min(a, b); }, INF);",
			"//SegmentTree< int > seg2(N, [](int a, int b) { return min(a, b); }, INF);",
			"//SegmentTree< int > seg(N, [](int a, int b) { return max(a, b); }, -INF);",
			"//SegmentTree< int > seg(N, [](int a, int b) { return (a+b); }, 0);",
			"// 1-indexed",
			"while(Q--) {",
			"  int T, X, Y;",
			"  cin>>T>>X>>Y;",
			"  if(T == 0){",
			"      seg.update(X, Y);",
			"  }",
			"  else{",
			"      cout<<seg.query(X,Y+1);",
			"  }",
			"}"
		],
		"description": "セグ木　ライブラリ",
	},

	"素数": {
		"scope": "cpp",
		"prefix": "sosuu",
		"body": [
			"vector<ll> enumPrimes(int n){",
			"    vector<ll> ret;",
			"    if(n<2) return ret;",
			"    vector<bool> prime(n+1, true);",
			"    prime[0]=false;",
			"    prime[1]=false;",
			"    for(ll i=0;i<prime.size();i++){",
			"        if(prime[i]){",
			"            ret.push_back(i);",
			"            for(ll j=2*i;j<prime.size();j+=i){",
			"                prime[j]=false;",
			"            }",
			"        }",
			"    }",
			"    return ret;",
			"}",
			"",
			"vector<ll> enumPrimes(ll l, ll r){",
			"    vector<ll> ret;",
			"    if(l<2) l=2;",
			"    if(l>r) return ret;",
			"    vector<bool> prime_small((int)sqrt(r)+2, true);",
			"    vector<bool> prime_big(r-l+1, true);",
			"    prime_small[0]=false;",
			"    prime_small[1]=false;",
			"    for(ll i=0;i<prime_small.size();i++){",
			"        if(prime_small[i]){",
			"            for(ll j=2*i;j<prime_small.size();j+=i){",
			"                prime_small[j]=false;",
			"            }",
			"            for(ll j=max(2*i,(l/i)*i);j<=r;j+=i){",
			"                if(l<=j) prime_big[j-l] = false;",
			"            }",
			"        }",
			"    }",
			"    for(ll i=l;i<=r;i++) if(prime_big[i-l]){",
			"        cout<<i<<endl;",
			"        ret.push_back(i);",
			"    }",
			"    return ret;",
			"}",
			"",
			"vector<ll> liniarPrimes(ll N){",
			"    vector<ll> prime;",
			"    vector<ll> lpf(N+1);",
			"    for(ll d=2; d<=N; d++){",
			"        if(lpf[d]==0){",
			"            lpf[d] = d;",
			"            prime.emplace_back(d);",
			"        }",
			"        for(auto p:prime){",
			"            if(p*d>N) break;",
			"            if(p>lpf[d]) break;",
			"            lpf[p*d] = p;",
			"        }",
			"    }",
			"    return prime;",
			"}",
			"",
			"vector<ll> lpf(ll N){",
			"    //最小素因数",
			"    ll inf = (1LL<<62)-1;",
			"    vector<ll> lpf(N+1, inf);",
			"    lpf[0] = 1;",
			"    lpf[1] = 1;",
			"    for(ll d=2; d<=N; d++){",
			"        if(lpf[d]==inf){",
			"            lpf[d] = d;",
			"            for(ll e = d*2;e<=N;e+=d){",
			"                lpf[e] = min(lpf[e], d);",
			"            }",
			"        }",
			"    }",
			"    return lpf;",
			"}",
			"",
			"vector<ll> gpf(ll N){",
			"    //最大素因数",
			"    vector<ll> gpf(N+1, 0);",
			"    gpf[0] = 1;",
			"    gpf[1] = 1;",
			"    for(ll d=2; d<=N; d++){",
			"        if(gpf[d]==0){",
			"            gpf[d] = d;",
			"            for(ll e = d*2;e<=N;e+=d){",
			"                gpf[e] = d;",
			"            }",
			"        }",
			"    }",
			"    return gpf;",
			"}",
			""
		],
		"description": "素数列挙．エラトステネスの篩．線形篩．最大素因数，最小素因数",
	},

	"多項式": {
		"scope": "cpp",
		"prefix": "poly divide",
		"body": [
			"//pair<Q, R> = pair< A/B, A%B > 0項目が最大次数",
			"pair<vector<int>, vector<int>> polyDivide(vector<int> A, vector<int> B){",
			"    //preprocessing",
			"    if(A[0]==0){",
			"        reverse(A.begin(), A.end());",
			"        while(A.back()==0) A.pop_back();",
			"        reverse(A.begin(), A.end());",
			"    }",
			"    if(B[0]==0){",
			"        reverse(B.begin(), B.end());",
			"        while(B.back()==0) B.pop_back();",
			"        reverse(B.begin(), B.end());",
			"    }",
			"    ",
			"    //ans",
			"    int lenA = A.size();",
			"    int lenB = B.size();",
			"    vector<int> Q;",
			"    for(int i=0;i+lenB<=lenA;i++){",
			"        int q = 0;",
			"        if(A[i]!=0){",
			"            q = A[i]/B[0];",
			"            for(int j=0;j<lenB;j++){",
			"                A[i+j] -= q*B[j];",
			"            }",
			"        }",
			"        Q.push_back(q);",
			"    }",
			"",
			"    vector<int> R = A;",
			"    if(!R.empty() && R[0]==0){",
			"        reverse(R.begin(), R.end());",
			"        while(!R.empty() && R.back()==0) R.pop_back();",
			"        reverse(R.begin(), R.end());",
			"    }",
			"",
			"    return {Q, R};",
			"",
			"}",
			"",
			"//vector<int> A = {1,6,9};",
			"//vector<int> B = {1,3};",
			"//reverse(A.begin(),A.end());",
			"//reverse(B.begin(),B.end());",
			"//auto C = polyDivide(A,B);",
			"//auto Q = C.first;",
			"//auto R = C.second;",
			"//reverse(Q.begin(), Q.end());",
			"//reverse(R.begin(), R.end());",
			"//PL(Q) // 1 3",
			"//EL(R) // あまりないのでsize=0",
		],
		"description": "多項式計算",
	},

	"転倒数（セグ木）": {
		"scope": "cpp",
		"prefix": "tenntousuu",
		"body": [
			"#if __has_include(<atcoder/segtree>)",
			"#include <atcoder/segtree>",
			"using namespace atcoder;",
			"ll RMQop(ll a, ll b){return max(a,b);}",
			"ll RMQe(){return -INF;}",
			"using RMQ = segtree<ll, RMQop,RMQe>;//Range Max Query",
			"ll RmQop(ll a, ll b){return min(a,b);}",
			"ll RmQe(){return INF;}",
			"using RmQ = segtree<ll, RmQop,RmQe>;// RmQ tree(vec); tree.prod(l,r)", 
			"ll RSQop(ll a, ll b){return a+b;}",
			"ll RSQe(){return 0LL;}",
			"using RSQ = segtree<ll, RSQop,RSQe>;//Range Sum Query",
			"ll seg_target;",
			"bool f(ll v){return v<seg_target;}//seg.max_right<f>(x-1)",
			"#endif",
			"",
			"template <typename T> vector<T> CCompress(vector<T>& A){",
			"   vector<T> B = A;",
			"   sort(B.begin(), B.end());",
			"   B.erase(unique(B.begin(), B.end()), B.end());",
			"   for(int i=0;i<(int)A.size();i++){",
			"      A[i] = (int)(lower_bound(B.begin(), B.end(), A[i]) - B.begin());",
			"   }",
			"   return B;",
			"}",
			"",
			"template <typename T> ll inversion_number(vector<T>& A, ll mod = 0){",
			"   int sz = CCompress(A).size();",
			"   ll ret = 0;",
			"   RSQ tree(sz);",
			"   for(int i=0;i<(int)A.size();i++){",
			"      ret += i-tree.prod(0, A[i]+1);",
			"      if(mod) ret%=mod;",
			"      tree.set(A[i], tree.get(A[i])+1);",
			"   }",
			"   return ret;",
			"}",
			"//vector<int> A = {1,100,5,5};",
			"//auto result = inversion_number(A);",
			"//-> result = 2",
		],
		"description": "転倒数 (atcoder::segtree)",
	},

	"転倒数（バブルソート）": {
		"scope": "cpp",
		"prefix": "tenntousuu",
		"body": [
			"template <typename T>",
			"long long BubbleSort(vector<T>& A) {",
			"    long long cnt = 0;",
			"    for(int i = 0; i < A.size(); i++) {",
			"        for(int j = A.size() - 1; j > i; j--) {",
			"            if(A[j] < A[j - 1]) {",
			"                swap(A[j], A[j - 1]);",
			"                cnt++;",
			"            }",
			"        }",
			"    }",
			"    return cnt;",
			"}",
			"//vector<int> A = {3,1,4,1,5};",
			"//int inv = BubbleSort(A);",
			"//-> inv=3, A={1,1,3,4,5}",
		],
		"description": "転倒数（バブルソート）",
	},

	"累積・等差数列和": {
		"scope": "cpp",
		"prefix": "acc sum xor",
		"body": [
			"template < typename T , typename S>",
			"T sum_of_arithmetic_sequence(const T a, const S d,",
			"                                const S n) {",
			"  return T(n) * (2 * a + T(n - 1) * d) / 2;",
			"}",
			"",
			"ll acc_xor(ll x){",
			"    //[0,x]の累積和 O(1). ABC121D",
			"    if(x<=0) return 0;",
			"    if(x%2==1) return (x+1)/2%2;",
			"    else return ((x+1)/2%2)^x;",
			"}",
			"",
			"ll acc_xor(ll x){",
			"    //[0,x]の累積xor計算",
			"    ll ans = 0;",
			"    rep(i,60){",
			"        ll n = 0;",
			"        ll d = 1LL<<(i+1);",
			"        n += (x)/d;",
			"        n%=2;",
			"        n *= 1LL<<(i);",
			"        n%=2;",
			"        //端数計算",
			"        ll m = 0;",
			"        m += max(0LL,(x)%d+1-(1LL<<(i)));",
			"        if((n+m)&1) ans += (1LL<<i);",
			"    }",
			"    return ans;",
			"}",
			"",
			"ll acc_sum(ll x){",
			"    //[0,x]の累積和",
			"    return (x)*(x+1)/2;",
			"}",
		],
		"description": "等差数列和",
	},

	"二分探索": {
		"scope": "cpp",
		"prefix": "binary search",
		"body": [
			"template<typename T, typename F>",
			"T binSearch(T ok, T ng, F check){",
			"   while(abs(ok-ng)>1){",
			"       T mid = (ok+ng)/2;",
			"       if(check(mid)) ok=mid;",
			"       else ng=mid;",
			"   }",
			"   return ok;",
			"}",
			"",
			"auto check = [&](auto x){",
			"   if(x>1) return true;",
			"   return false;",
			"};",
		],
		"description": "二分探索",
	},

	"熨斗基底": {
		"scope": "cpp",
		"prefix": "Noshi　base",
		"body": [
			"V<ll> C;",
			"V<ll> bases;",
			"for(auto c:C){",
			"   for(auto b:bases) chmin(c, c^b);",
			"   if(c){",
			"      bases.push_back(id);",
			"   }",
			"}",
		],
		"description": "xor 基底",
	},

	"バブルソート": {
		"scope": "cpp",
		"prefix": "baburuso-to",
		"body": [
			"template <typename T>",
			"long long BubbleSort(vector<T>& A) {",
			"    long long cnt = 0;",
			"    for(int i = 0; i < A.size(); i++) {",
			"        for(int j = A.size() - 1; j > i; j--) {",
			"            if(A[j] < A[j - 1]) {",
			"                swap(A[j], A[j - 1]);",
			"                cnt++;",
			"            }",
			"        }",
			"    }",
			"    return cnt;",
			"}",
			"//vector<int> A = {3,1,4,1,5};",
			"//int inv = BubbleSort(A);",
			"//-> inv=3, A={1,1,3,4,5}",
		],
		"description": "バブルソート",
	},

	"2次元ベクトル": {
		"scope": "cpp",
		"prefix": "a/aa",
		"body": [
			"template <typename T>",
			"struct Vec2T{",
			"    vector<T> v;",
			"",
			"    Vec2T():v(vector<T>(2)){}",
			"",
			"    Vec2T(T x, T y):v(vector<T>(2)){",
			"        v[0]=x; v[1]=y;",
			"    }",
			"",
			"    size_t size(){",
			"        return v.size();",
			"    }",
			"",
			"    inline const T &operator[](int k) const{",
			"        return (v[k]);",
			"    }",
			"",
			"    inline T &operator[](int k){",
			"        return (v[k]);",
			"    }",
			"",
			"    ///行列同士の演算",
			"    Vec2T &operator+=(const Vec2T& A){",
			"        this->v[0] += A.v[0];",
			"        this->v[1] += A.v[1];",
			"        return (*this);",
			"    }",
			"    Vec2T operator+(const Vec2T& A){",
			"        return (Vec2T(*this)+=A);",
			"    }",
			"    Vec2T &operator-=(const Vec2T& A){",
			"        this->v[0] -= A.v[0];",
			"        this->v[1] -= A.v[1];",
			"        return (*this);",
			"    }",
			"    Vec2T operator-(const Vec2T& A){",
			"        return (Vec2T(*this)-=A);",
			"    }",
			"    T outer_product(const Vec2T& A){",
			"        return T(this->v[0]*A.v[1] - this->v[1]*A.v[0]);",
			"    }",
			"    T inner_product(const Vec2T& A){",
			"        return T(this->v[0]*A.v[0] + this->v[1]*A.v[1]);",
			"    }",
			"",
			"    ///行列とスカラーの演算",
			"    Vec2T &operator+=(const T& a){",
			"        this->v[0] += a;",
			"        this->v[1] += a;",
			"        return (*this);",
			"    }",
			"    Vec2T operator+(const T& a){",
			"        return (Vec2T(*this)+=a);",
			"    }",
			"    Vec2T &operator-=(const T& a){",
			"        this->v[0] -= a;",
			"        this->v[1] -= a;",
			"        return (*this);",
			"    }",
			"    Vec2T operator-(const T& a){",
			"        return (Vec2T(*this)-=a);",
			"    }",
			"    Vec2T &operator*=(const T& a){",
			"        this->v[0] *= a;",
			"        this->v[1] *= a;",
			"        return (*this);",
			"    }",
			"    Vec2T operator*(const T& a){",
			"        return (Vec2T(*this)*=a);",
			"    }",
			"    Vec2T &operator/=(const T& a){",
			"        this->v[0] /= a;",
			"        this->v[1] /= a;",
			"        return (*this);",
			"    }",
			"    Vec2T operator/(const T& a){",
			"        return (Vec2T(*this)/=a);",
			"    }",
			"",
			"",
			"    ///回転演算",
			"    Vec2T rotate_rad(const T& a){",
			"        return Vec2T(",
			"            this->v[0]*cos(a) - this->v[1]*sin(a),",
			"            this->v[0]*sin(a) + this->v[1]*cos(a)",
			"        );",
			"    }",
			"    Vec2T rotate_deg(T a){",
			"        a = a * M_PI / 180;",
			"        return Vec2T(",
			"            this->v[0]*cos(a) - this->v[1]*sin(a),",
			"            this->v[0]*sin(a) + this->v[1]*cos(a)",
			"        );",
			"    }",
			"",
			"    //ノルム",
			"    double norm(){",
			"        return sqrt(v[0]*v[0]+v[1]*v[1]);",
			"    }",
			"",
			"    //角度",
			"    double angle_rad(Vec2T& A){",
			"        return asin((double)((*this).outer_product(A))/(*this).norm()/A.norm());",
			"    }",
			"",
			"    double angle_deg(Vec2T& A){",
			"        return asin((double)((*this).outer_product(A))/(*this).norm()/A.norm())*180/M_PI;",
			"    }",
			"",
			"    ///比較演算",
			"    bool operator<(const Vec2T& A){",
			"        if(this->v[0]!=A.v[0]) return (this->v[0]<A.v[0]);",
			"        return (this->v[1]<A.v[1]);",
			"    }",
			"    bool operator==(const Vec2T& A){",
			"        if(this->v[0]!=A.v[0]) return false;",
			"        if(this->v[1]!=A.v[1]) return false;        ",
			"        return true;",
			"    }",
			"",
			"    //入出力",
			"    friend istream &operator>>(istream &is, Vec2T<T> &vec) {",
			"        is>>vec.v[0]>>vec.v[1];",
			"        return is;",
			"    }",
			"    friend ostream &operator<<(ostream &os, Vec2T<T> &vec) {",
			"        os<<vec.v[0]<<\" \"<<vec.v[1];",
			"        return os;",
			"    }",
			"",
			"    ///2点間直線の唯一性評価用 dx,dy",
			"    vector<T> info(){",
			"        T dx = this->v[0];",
			"        T dy = this->v[1];",
			"",
			"        if(dx==0 && dy==0){}",
			"        else if(dx==0) dy = 1;",
			"        else if(dy==0) dx = 1;",
			"        else{",
			"            T GCD = gcd(dx, dy);",
			"            dx /= GCD;",
			"            dy /= GCD;",
			"        }",
			"",
			"        vector<T> ret(2);//dx, dy",
			"        ret[0] = dx;",
			"        ret[1] = dy;",
			"        return ret;",
			"    }",
			"",
			"",
			"    //直線A->Bへの垂線ベクトル",
			"    //    A + s*AB = C + t*P",
			"    //<=> s*AB - t*p = A-C",
			"    Vec2T<double> perpend(Vec2T& A, Vec2T& B){",
			"        Vec2T AB = B-A;",
			"        Vec2T p = AB;",
			"        swap(p.v[0], p.v[1]);",
			"        p.v[1] *= -1;",
			"",
			"        Vec2T R = A-(*this);",
			"        double det = -(AB[0]*p[0]) + AB[1]*p[1];",
			"        if(det==0) return Vec2T<double>(0,0);",
			"",
			"",
			"        double t;",
			"        t = (-p[0]*R[0] + p[1]*R[1])/det;",
			"",
			"        Vec2T<double> tP(p[0]*t, p[1]*t);",
			"",
			"        return tP;",
			"    }",
			"};",
			"",
			"Vec2T<int> A(0,0);",
			"Vec2T<int> B(5,0);",
			"Vec2T<int> O(0,0);",
			"",
			"auto C = A+B;",
			"EL(C)",
			"EL(A.outer_product(B))//外積，面積",
			"EL(A.inner_product(B))//内積",
			"EL((A-O).outer_product(B-O))//外積，面積",
			"EL((A-O).info())",
			"EL(A.norm())",
			"EL(A.angle_deg(B))",
			"EL(B.angle_deg(A))",
			"auto p = O.perpend(A, B);",
			"EL(p.v)",
			"EL(O.perpend(A,B).v)",
			"",
			"",
			"",
			"",
			"Vec2T<double> a; cin>>a;",
			"Vec2T<double> e(1., 0.);//x方向 単位ベクトル",
			"Vec2T<double> f = e.rotate_rad(M_PI/4);//45度回転",
			"Vec2T<double> g = e.rotate_deg(90);////90度回転",
			"EL(f)",
			"EL(g)",
			"EL(e==a)",
		],
		"description": "2次元ベクトル",
	},

	"約数列挙": {
		"scope": "cpp",
		"prefix": "yakusuurekkyo",
		"body": [
			"vector<ll> enumDivs(ll n, bool sorten=true){",
			"    vector<ll> result;",
			"    for(ll i=1;i*i<=n;i++){",
			"        if(n%i==0){",
			"            result.push_back(i);",
			"            if(i*i!=n) result.push_back(n/i);",
			"        }",
			"    }",
			"    if(sorten) sort(result.begin(), result.end());",
			"    return result;",
			"}",
			"",
			"map<ll, ll> prime_factor(ll n){",
			"    map<ll, ll> res;",
			"    for(ll i = 2; i * i <= n; i++){",
			"        while(n % i == 0){",
			"            ++res[i];",
			"            n /= i;",
			"        }",
			"    }",
			"    if(n != 1) res[n]++;",
			"    return res;",
			"}",
		],
		"description": "約数列挙 素因数分解",
	},

	"拡張ユークリッドの互除法": {
		"scope": "cpp",
		"prefix": "euclid extention",
		"body": [
			"long long extGCD(long long a, long long b, long long &x, long long &y) {",
			"    // 返り値: a と b の最大公約数",
			"    // ax + by = gcd(a, b) を満たす (x, y) が格納される",
			"    //x,yは初期化不要!",
			"    //ll x,y;",
			"    //ll g = extGCD(a,b,x,y);",
			"    if (b == 0) {",
			"        x = 1;",
			"        y = 0;",
			"        return a;",
			"    }",
			"    long long d = extGCD(b, a%b, y, x);",
			"    y -= a/b * x;",
			"    return d;",
			"}",
		],
		"description": "拡張ユークリッドの互除法",
	},

	"ランレングス圧縮": {
		"scope": "cpp",
		"prefix": "rannrenngusu",
		"body": [
			"vector<pair<char, int>> RLE(const string& s){",
			"   vector<pair<char, int>> ret;",
			"   for(int i=0;i<(int)s.size();i++){",
			"      if(ret.size()==0) ret.push_back({s[i],1});",
			"      else if(ret.back().first==s[i]) ret.back().second++;",
			"      else ret.push_back({s[i], 1});",
			"   }",
			"   return ret;",
			"}",
			"",
			"template <typename T>",
			"vector<pair<T, int>> RLE(const vector<T>& vec){",
			"   vector<pair<T, int>> ret;",
			"   for(int i=0;i<(int)vec.size();i++){",
			"      if(ret.size()==0) ret.push_back({vec[i],1});",
			"      else if(ret.back().first==vec[i]) ret.back().second++;",
			"      else ret.push_back({vec[i], 1});",
			"   }",
			"   return ret;",
			"}",
		],
		"description": "ランレングス圧縮 RLE",
	},






	/*
	python
	*/
	"input()": {
		"scope": "python",
		"prefix": "input()",
		"body": [
			"input()",
		],
		"description": "",
	},
	"int(input())": {
		"scope": "python",
		"prefix": "int(input())",
		"body": [
			"int(input())",
		],
		"description": "",
	},
	"map(int,input().split())": {
		"scope": "python",
		"prefix": "map(int,input().split())",
		"body": [
			"map(int,input().split())",
		],
		"description": "",
	},
	"list(map(int,input().split()))": {
		"scope": "python",
		"prefix": "list(map(int,input().split()))",
		"body": [
			"list(map(int,input().split()))",
		],
		"description": "",
	},
	"heapq": {
		"scope": "python",
		"prefix": "heapq",
		"body": [
			"import heapq",
			"#heapq.heapify(A)",
			"#heapq.heappop()",
			"#heapq.heappush()",
		],
		"description": "",
	},
}

	// Place your CPP ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
